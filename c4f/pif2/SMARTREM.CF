FORGET TT : TT ;


( DEFINITIONS ) \ SMARTREM INTERPRETTER
-1 |VALUE |LVL (LVL   
0 VALUE `(LOCATE  
: `LVL+ |LVL 1+ ; 
: `LVL- |LVL 1- ;  
: `>PAD STR| CSTR 
: `PAD, |HLD C!+ ; 
: `">PAD (LVL IF  DROP ;THEN  CSTR `>PAD BL `PAD, 1+ ;
: `//  DUP PAD ! ; 
: `) (LVL `LVL- 0<>; TO CSP  `(LOCATE TO LOCATE (# T TO vTARG ;
CREATE `T  ENTRY, `LVL+ ( ENTRY, `// //
 ENTRY, \ \  ENTRY, `) ) Z, Z, 0 C, ALIGNED 
: ( 0 PAD !+ TO HLD 0 (# ,< VAL' LOCATE , >, @ TO `(LOCATE 0 
TO (LVL (# `T TO vTARG  AT LOCATE TFND 2/ (WARY `">PAD @EXEC 
: >. TOKEN? ID. ;


( 1 2 3 4 5 // 0 9 8 7 6 5
\ 2 4 6 8 
09876 ) CR PAD @+ HLD OVER- TYPE . CSP .

---------?

' PARSTK  4 + CONST PARPTR^   : `@PAR @ PARPTR^ @ + ;   
-$600 $100 + -64 + CONST >EACH
0#> `@PAR @ ;  1#> `@PAR ! ;  2#> `@PAR ; 3MKR PQUAN ,

: `>EACH OVER XEP; 
: `EACH >EACH CSTR SBUF S! +S! STR EVAL ; 
: N`THP CALL
: ?LENP { ADR -- ADR LEN } [ 1- OVER- ] DUP 
: >NXTP { ADR-ADR` } 1 
: NPAR  THEN { ADR CNT -- ADR` } 
    FOR BEGIN CSTR BL = UNTIL NEXT DROP ; 
: REMARR} NIP; 
: COMMENT} PAD STR H @ XEP; DUP J OR 0;
    2DUP + 1- C@ BL - !"NO_COMMENT" ;
: SHOW} COMMENT} CR . TYPE ;
: EVAL} COMMENT} DROP EVAL ; 

2 0 8 FAMILY PQUAN  `V0 `V1 `V2 `V3 `V4 `V5 `V6 `V7 

: `ZEROS TIMES; 0 TO PARSTK ; : `FILLPAR TIMES; TO PARSTK ; 
: `SETPAR C@R+  C@R+ P>BYT XCHG PUSH `ZEROS `FILLPAR   EX
    POP PARPTR^ +! ;  : RETURN` `OLDT TO T ; 

\  FOUND TO `V3   COUNT  TO `V2    LEN TO `V1    LIST TO `V0 
: ``=: -1 : `=SEVAL  "=:_`" SEVAL  ; 
: <SKIP` AHEAD` ,<` CSTK> ; : SKIP> ``=: TO CSTK> >, THEN` ;
: FUNC: COMMENT} DUP FOUND - `SETPAR ,< 4 C, 0 C, >, bs `V2
    UMAX U< !"TOO_MANY_PARS" =H  T TO `OLDT "=:_" >EACH >" 
	`V2 FOR I 8 U* (LIT `V0 + `V0 I N`THP `EACH NEXT 
	`=SEVAL (LIT `SETPAR , `V2 `V3 - C, `V3 C, >, ;    

: TAB? 78 CNTC - U< CR ?; 2 SPACES ;

: HAN PUSH "SRC"_PILON" "TMP"_PILON" "DST"_PILON" POP ,<
{ SRC_PILON TMP_PILON DST_PILON DISKS } 
FUNC: HANOJ <SKIP 
    : .FROM SRC_PILON "From_"  
    : .PILON ID. ID. ; 
    : .TO DST_PILON "To_" .PILON ; 
SKIP> DISKS 0; 
        AT DISKS DEC DISKS IF 
	    SRC_PILON DST_PILON TMP_PILON DISKS  HANOJ
        SRC_PILON TMP_PILON DST_PILON 1      HANOJ
        TMP_PILON SRC_PILON DST_PILON DISKS  HANOJ ;;
THEN CR ."Move_Disk" .FROM SPACE .TO   RETURN  ;;


: QUINS CR 0 ,< 
{ X // IDX } 
FUNC: QUIN  <SKIP  
      8 CONST Q8  
      Q8 BARY ROW  
      Q8 BARY FROW  
   Q8 2* BARY DIAG\ 
   Q8 2* BARY DIAG/ 
            : ADD_QUIN IDX 1+ X ROW C! ; 
0#> PUSH IDX FROW IXEC X IDX + DIAG\ IXEC Q8 IDX - X + DIAG/ ;
           N: TEST  >, C@ OR ;
           N: SET   >, 1 CSWAP! ; 
           =, RESET >, 0 CSWAP! ;
SKIP>
  X Q8 - IF Q8 TIMES; 
  J TO IDX  0 TEST 0<>;
  ADD_QUIN SET X 1+ QUIN RESET ;
THEN [ Q8 TAB? ] 0 Q8 1- RNG>; ROW C@ ALPHA EMIT   RETURN ;


: PERM CR CSTR 20 UMIN 
<SKIP   0 VALUE `LEN   20 BARY `ARP  : `>ARP 0 `ARP ;
: `PRINT [ `LEN TAB? ] `>ARP `LEN TYPE ; 
: `SWAP { S D } `ARP PUSH `ARP DUP PUSH
    C@ { S@ } J  C@ { D@ } POP C! { S! } POP  C! { D! } ;
SKIP>  DUP TO `LEN `>ARP MOVM `LEN  ,< 
{ N } 
FUNC: `PERMUTE <SKIP SKIP>
    N 0;  AT N DEC  N `PRINT ?; 
	N `PERMUTE  N TIMES;  J N `SWAP  N `PERMUTE  J N `SWAP  
RETURN ;

{ >A >L A L { INSERTING A L WITH BLANK -- >A` >L` } }
FUNC: S"INSERT 
<SKIP   : INS DUP AT >L +! >A (MPUSH TO >A ;
SKIP>   "_" CSTR INS A L INS   >A >L RETURN ;

: SIGNA SPC; [ : `SEMIT DUP EMIT ] XEP; ,<
{ A B C D E F G H } FUNC: `ASIGN
    CR
    A `SEMIT B `SEMIT C `SEMIT D `SEMIT
    E `SEMIT F `SEMIT G `SEMIT H `SEMIT 
RETURN ;

: /SCANI NOT I+ 2EXIT ; 

: BSCAN> W>B ROT >A; PUSH DUP PUSH AHEAD 
BEGIN 
  XA C@R+ XA J - /SCANI ?; THEN 
UNTIL- 2EXIT ;
 
: SCAN ROT >A; PUSH DUP PUSH AHEAD BEGIN
 XA @R+ XA J - /SCANI ?; THEN UNTIL- 2EXIT ;

: TRICE PUSH J XCHG J PUSH ; : UNUM. SPC; DUP 5 U.R ;
: 3DUP DUP B.S TRICE PICK ;
: OK/FAIL> DUP PUSH ' >NF< ID. EXECUTE UNUM. H + C@ POP
: ASERT - IF ."FAL_" ;THEN ."OK__" ;

{ CR 'S 'I 'G 'N 'A 'T 'U 'R 'E SIGNA CR 
    H 32 ERASE  "ABCD_ABCD_" DROP  H 14 DUMP CR
    SIGNA H 14  1 3DUP OK/FAIL> BSCAN  OK/FAIL> BSCAN>  
    SIGNA H 14  2 3DUP OK/FAIL> BSCAN  OK/FAIL> BSCAN>  
    SIGNA H 14  3 3DUP OK/FAIL> BSCAN  OK/FAIL> BSCAN> 
    SIGNA H 14 'B 3DUP OK/FAIL> BSCAN  OK/FAIL> BSCAN> ."B" 
    SIGNA H 14 0  3DUP OK/FAIL> BSCAN  OK/FAIL> BSCAN> ."ZERO"
    SIGNA H 14 BL 3DUP OK/FAIL> BSCAN  OK/FAIL> BSCAN> ."SPCE"
    SIGNA H 14 10 3DUP OK/FAIL> BSCAN  OK/FAIL> BSCAN>  
    SIGNA H 14 'A 3DUP OK/FAIL> BSCAN  OK/FAIL> BSCAN> ."A"
    SIGNA H 14 'B 3DUP OK/FAIL> BSCAN  OK/FAIL> BSCAN> ."B"
    SIGNA H 14 'C 3DUP OK/FAIL> BSCAN  OK/FAIL> BSCAN> ."C"
    SIGNA H 14 'D 3DUP OK/FAIL> BSCAN  OK/FAIL> BSCAN> ."D"
    SIGNA H 14 99 3DUP OK/FAIL> BSCAN  OK/FAIL> BSCAN> ."E"
    CR SIGNA  WITH EMIT 9 TIMES
} EVAL}
CR
ARGRGSFDGSDFGDS


: FOREACH >EACH >" COMMENT} TBUF BL ERASE ,< 
{ SADR SLEN CNT // STEP OFST DEST } 
FUNC: `FOREACH 
<SKIP 
: CHAR+ DEST C!+ TO DEST ; 
: BAD 1 : BAD? !"PARAMS?" ; 
: DFLT DROP : DEFAULT 1 TO STEP "_^A" >EACH "+! DROP ; 
: HAS_PARAMS? [ TBUF CSTR BAD? BL 1- 0 BSCAN> DFLT ?; DUP
 TO STEP DEFAULT ?; ] >EACH CSTR .TIMES; CSTR DUP BL U< DROP ?;
 TBUF + INC ; 
: PREPARE [ SADR STEP DUP AT SLEN +! NPAR TO SADR ] OFST 
 TO DEST >EACH CSTR .TIMES; CSTR DUP BL U< CHAR+ ?; 1-
 PUSH  SADR POP N`THP .TIMES; CSTR CHAR+ ; 
SKIP> CNT 0; SADR SLEN + TO OFST SADR CNT NPAR OFST - BAD? 
    HAS_PARAMS? CNT STEP (/MD !"ODDLIST" 0 TO SLEN
	TIMES; PREPARE OFST DEST OVER- EVAL RETURN ;

: ** DUP U* ; : 2^ 1 SWAP TIMES; 2* ;
CR { ASDF ASFD AFDS AFSD } """^A""_ID." FOREACH 
CR 0 { %1111 $20 '~ 3#200 7#100 99 ^A 'A } 
">NUM_^A_." FOREACH .
CR { %1111 $20 '~ 3#200 7#100 99 ^A 'A } 
">NUM_^A_NEG_." FOREACH 
CR { %1111 $20 '~ 3#200 7#100 99 ^A 'A } 
">NUM_^A_**_." FOREACH 

CR { + - U* U/ 2* 2/ UMOD NEG } ">." FOREACH
CR { + - U* U/ 2* 2/ UMOD NEG }
 "'_^A_'$_EMIT_H._>._=:_>._^A" FOREACH
CR { + - U* U/ 2* 2/ UMOD NEG } ">._^A_>._=:_>._^B" FOREACH
{ 1 A1 2 B1 3 C1 4 D1 5 E1 6 F1 } 
">NUM_^A_CONST_^B" FOREACH 

CR { 1 . 2 3 + } "" FOREACH
CR 

{ \ DFGHDFGH
: \ DFGHDFGHDFGH
A \ SDFGHDFGHDFGHDFG
2 { SDFGHSDFGHDFG { SDFGSDFGSDF } }
3 \ SDFGDFGHFD
+ { FDGHDFGHDFG
}
.
;
} SHOW} EVAL}
