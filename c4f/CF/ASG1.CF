: WRD, , ;
: MKID PUSH 1H <# # # # # POP HOLD #>  TO S>"! ;
: BYTE>SIGNED DUP 128 AND 0; -128 OR  ;
: I@ J @ ;
2 CONST CELL#
' 2+ =: CELL+
' 2- =: CELL-
' 2* =: CELLS  \ : CELLS ( CELL# HIBIT TIMES| ) 2* ;
: CELLS+ CELLS + ;
0 VALUE HIBBB \ MAX BBB INDEX  
0 VECTOR BBB[] 
' C@ VECTOR AS-C@
0 VALUE BIBYBA-COUNTER  \ BIBYBA COUNT OF ELEMENTS
T VALUE STARTVOC
: IDS. |DROP T CALL WHILE| 
: `IDS1 DUP @ 
\ '$ EMIT H. 
 . \ NUMOUT
."=:_" DUP WID. CR
: `IDS2  >DEA THEN : `IDS3 DUP STARTVOC - ;
: STEPPED. |DROP T `IDS3 WHILE| DUP CELL+ @
  $8000 AND IF ? `IDS2    `IDS1 ;
: UNSTEPPED. |DROP T `IDS3 WHILE| 
  DUP 5+ C@ '@ = IF ? `IDS2
  DUP CELL+ @   $8000 AND IF ? `IDS1    `IDS2 ;
: NAMES. |DROP T CALL WHILE|
 DUP @ '$ EMIT H. ."=:_" 
 DUP WID. CR >DEA THEN DEA? ;

EXPORT SHOW-ALL   \ FIRST TO EXPORT
EXPORT SHOW-PI  
EXPORT SHOW-FR  
EXPORT SHOW-FI  
EXPORT SHOW-,   
EXPORT SHOW:
EXPORT FSHOW
EXPORT TB^
EXPORT DDF
EXPORT DDD
EXPORT D-S
EXPORT DT
EXPORT DTA
EXPORT DIZABY
EXPORT D-R
EXPORT COMMAER
EXPORT .COMMA-STANDARD
EXPORT .COMMA-(RX)
EXPORT .COMMA-(RB)
EXPORT (S,)
EXPORT (DB,)
EXPORT .COMMA-IMM 
EXPORT .COMMA-SIGNED
EXPORT (DA,)
EXPORT (DW,)
EXPORT .COMMA-ADR
EXPORT .COMMA-SIGN-BYTE
EXPORT TBB.
EXPORT DEZOBJ
EXPORT DEZORG
EXPORT 1PI
EXPORT 2PI
EXPORT 1FR
EXPORT 1FI
EXPORT >CODE 
EXPORT ;CODE 
EXPORT ENDER   \ LAST  TO EXPORT
( ) FUNC: `  ,< UNW UNW 

\ COMMON VARIABLES AND FUNCTIONS
1 VALUE  I-ALIGNMENT ( Instruction alignment )
VARIABLE BA-DEFAULT    0 BA-DEFAULT !
VARIABLE BA-XT
\ : |AS-POINTER@ EX DUP 
: `DEZOBJ DUP $. ."OBJ_" ,<
0 VALUE AS-POINTER@
: `DEZORG DUP $. ."ORG_" AS-POINTER@ SWAP - ,< \ TO DEASMOF ;
0 VALUE DEASMOF \ OFFSET ON DEZASSEMBLING
'   H  =: AS-HERE
'   C, =: AS-C,
0 VALUE ISL@  ( Length of current instruction )
: !ISS AS-HERE ,<
0 VALUE  ISS@  ( Start of current instruction )
: `RADR AS-POINTER@  \ OBJECT ADDRESS IN MEMORY
: >RADR DEASMOF - ;  \ REAL ADDRESS

: `!HIDDEN? AS-POINTER@ ,<  0 VALUE POINTER2
: |AS-SPC '\ CALL EX
: !AS-SPC BL THEN ,<  BL VALUE AS-SPC
ADR' NOP VECTOR IMMTEST
: |TEST EX  POINTER2 0;  \ NO INSTUCTION
   ISS@ POINTER2 - 0;    \ NO IMMEDIATE PART
   AS-SPC '\ - 0;        \ ALREADY TESTING
   |AS-SPC IMMTEST ;
 
\ : HIBIT 0 SWAP |DROP CALL WHILE| U1+ THEN 2/ DUP ;
\ : HIBIT 0 SWAP [ DROP 1- ] UNTILZ| U1+ 2/ DUP ;
: !POSTIT  !ISS
: !OLDCOMMA 0 ,<
0 VALUE OLDCOMMA@
\ : >CURL DUP @ 5+ C@  ,<
0 VALUE CURL

\ : >DIS  @ 3 
: >DATA @ CELL+ ;
: HERE- AS-HERE CELL- ;
: CORRECT-R CELL# CURL -
: LSHIFTB TIMES| B* ;       \ SHIFT BYTES LEFT
\ : B* 8 \ : << TIMES| 2* ; \ LSHIFT
: CORRECT-L CELL# CURL -
: RSHIFTB TIMES| B/ ;        \ SHIFT BYTES RIGHT
\ : B/ 8 \ : >> TIMES| 2/ ; \ RSHIFT
: CHECK28 2DUP AND !28"  ;  \ PRE OR CHK
\ : FIXUP<   CORRECT-R ISS@ 
: OR!?   |@! CHECK28 OR ;

\ : SPLIT, SPLIT
\ : BB, C, C, ;
\ 

\ \\\\\\\\\\\\\\\\ ASSEMBLER GEN \\\\\\\\\\\\\\\\\\\\\

: IS-A VARIABLE HERE- DOES> PUSH @ @ @R+ = EXIT ; \ CHECK TYPE
: REMEMBER` ?CSP HERE- SWAP! CSP! ;  \ REMEMBER TYPE

( ------------- BOOKKEEPING ---------------------- )

\ BI - Bits that needs fixed up
CREATE TBI     Z, Z, Z,  \ THE BLACK BOARD IS CLEAR
\ BY - Bits represent a commaer that is to be supplied
TBI 1 CELLS + CONST TBY
\ BA - State bits, bad if two consequitive bits are up
TBI 2 CELLS + CONST TBA

: @BBB DUP @ 4+   \ DEA / DEA ADDRESS (CURL := LENGTH)
: BBB@BODY+  C@+  C@ TO CURL   BBB[] DUP ,< 
                \ SIZE    TALLY:,  TALLY:|  TALLY:,,
0 VALUE BI^     \ WORDP   OR!      AND!     --      >BI  
: BY^ BI^ 2+ ;  \ BYTEP   OR!      OR!      AND!    >BY  
: BA^ BI^ 3 + ; \ BYTEP   OR!U     OR!U     OR!U    >BA  


<M>
: `[]>BI DUP BBB[] TO BI^ 1+ ; 
: `TBI? 0 BIBYBA-COUNTER TBI SCN| `[]>BI DUP \ FLAG NOT FOUND
  BI^ @ TBI @ - 0<>;   BY^ C@ TBY @ - 0<>;
  BA^ C@ TBA @ - 0<>; DUP - ; \ 0 - FLAG FOUND

: `TB^ [ 1- TO BI^ ]  TBI !  TBY !  TBA !  `TBI? 1+ 0<>; DROP 
 BIBYBA-COUNTER `[]>BI DUP HIBBB U< 0"BBC?" DUP 
 TO BIBYBA-COUNTER  TBI @ BI^ ! TBY @ BY^ C!  TBA @ BA^ C! ;
>, >FILE 
: TB. 0 BBB[] BIBYBA-COUNTER STR| STR H. CSTR B. CSTR B. CR ;
<M>


: BAD? TBA  @
: BADPAIRS? DUP 2* AND $AAAAAAAAAAAAAAAA AND ;
: CHECK32 BAD? !PAIRS!" ; ( Always an error )
: CHECK29  2DUP OR -1 - !PRE&CHK!"   ;  \ PRE AND CHK
: AND!?  PUSH NOT @I CHECK29 AND POP! ;
: AT-REST?  TBI @ 0=   TBY @ 0=  AND ;
: MC<0 + 1- C@  $80 SWAP 
: CONTAINED-IN  OVER AND = ; ( leaving it IS      )
: CHECK26 AT-REST? 0"postit!" ;  ( Error at postit time )
: CHECK30 DUP OLDCOMMA@ < !COMMAER!" DUP TO OLDCOMMA@ ;
: RESET-BAD   BA-XT @ DUP IF PUSH ] DROP  BA-DEFAULT @ TBA ! ;
( *************** PREFERRED NOT YET USED ******************* )
( If bits were already down it is wrong. For next two words. )
( Reset bits of DATA into ADDRESS bytewise. )
: (AND!BYTE) PUSH $FF AND NOT I C@ CHECK29 AND
: POPC! POP C! ;
( Reset bits of DATA byte by byte into ADDRESS )
: AND!BYTE BEGIN 2DUP (AND!BYTE) SWAP B/
              DUP WHILE SWAP 1+ REPEAT 2DROP ;
( If bits were already up its wrong. for next two words. )
( Or DATA into ADDRESS bytewise. )
: (OR!BYTE) DUP PUSH C@  CHECK28 OR POPC! ;
( Or DATA byte by byte from behind into ADDRESS )
: OR!BYTE BEGIN 1- 2DUP (OR!BYTE) SWAP
           B/ DUP WHILE SWAP REPEAT 2DROP ;
: assem, CELL#
: assemble,  STR| 
: lsbyte, DUP AS-C, B/ ;

\ TALLIES  ------------------------------------------------
: !TALLY  0 TBI !  0 TBY !  RESET-BAD  !OLDCOMMA  ; 
: TALLY:, STR TBI ! CSTR TBY !
: ;TALLY C@ TBA 
: OR!U |@! OR ;
: TALLY:| STR TBI AND!? CSTR TBY OR!? ;TALLY ;
: TALLY:,, CELL+ CSTR CHECK30 TBY AND!? ;TALLY ;

\ : |SHOW` DUP CR 2- ?ID. DUP @ H.
\ EX |SPC TO BK H DUP H. 6 A-L |[] BYTES. ;

\ Bits  ON COMMAERS  ---------------------------------
\ $80 (RX,) address relative to IP : CELL
\ $40 (RB,) address relative to IP : byte
\ $20 SG,   Segment: WORD
\ $10 P,    port number : byte
\  $8 IS,   immediate byte data, obligatory size
\  $4 IX,   immediate data : cell
\  $4 IB,   immediate byte data
\  $2 X,    immediate data : address/offset
\  $2 B,    immediate byte : address/offset
\  $1 W,    obligatory word

\ Bits - BI  -------------------------------------
\   1 OPERAND IS BYTE
\   2 OPERAND IS CELL
\   4 OFFSET DB|
\   8 ADDRESS  DW|
\  10 Register op
\  20 Memory op
\  40 D0
\  80 [BP]

\ MAKERS -------------------------------------------------
: TB, BI^ C, ; \ ON COMPILE TIME ONLY
IS-A IS-COMMA
: `COMMAER CREATE  ,'  \ ASSEMLER COMMAER (CELL)
   TB, C, \ BIBYBA INDEX   (BYTE) \ LENGTH OF OPERAND (BYTE)   
   DOES> REMEMBER STR PUSH BBB@BODY+ TALLY:,, ;
IS-A IS-1PI
: `1PI CREATE-- assem, TB,  1 C, DOES> REMEMBER
: POSTIT DUP CELL+ CHECK26 !TALLY  
   !POSTIT BBB@BODY+  TALLY:, CURL  DUP TO ISL@  S, ;
IS-A IS-2PI
: `2PI CREATE-- assem, TB,  2 C, DOES> REMEMBER POSTIT ;
IS-A IS-1FR
: `1FR CREATE-- assem, TB,  1 C, DOES> REMEMBER
: FIXUP>   STR HERE-
: FIXUP OR!? BBB@BODY+ TALLY:| CHECK32 ;
IS-A IS-1FI
: `1FI CREATE-- assem, TB, 1 C, DOES> REMEMBER STR ISS@ FIXUP ;
IS-A `IS-END
: `ENDER <BUILD DOES> REMEMBER ;; ,< \ NO TAIL
: IS-PI DUP IS-1PI  SWAP  IS-2PI  OR ;
: IS-F  DUP IS-1FR  SWAP  IS-1FI  OR ;
: IS-OP DUP IS-PI   OVER  IS-F    OR  SWAP IS-COMMA OR ;      

\ ------------- DATA STRUCTURES --------------------------
( A row of dea's representing a disassembly )
12 KIT: DISS    : !DISS AT DISS KIT! ;  !DISS
: DISS-  DISS DROP ;     \ Discard last item of `DISS'
: DISS" AT DISS KIT" ;   ( `DISS' STATE )
: DISS? AT DISS KIT? ;   ( `DISS' COUNT )
: DISS. |CR SPC DISS" STR| @+ XEP| DUP IS-COMMA
  IF J AT DISS 6 + - . THEN WID.  ;
' DISS.  VECTOR DISS-VECTOR

\ ------------- TRYERS ---------------------------
: @BBW. [ CSTR ] AHEAD   : SPHHH. XEP|  SP@  TBI SWAP
: @HHH. [ STR ] THEN CR H. SPC STR H. (IXEC H. EX H. DROP ;
: DB2. BI^ DUP @BBW.     : DB. SPHHH. ". DBG. ;

\ 0 VALUE IN-PI

: TRY-PI DUP IS-PI 0; AT-REST? 0; @BBB TALLY:,
: DISS+ DUP TO DISS
\ IN-PI IF [ @BBB DROP ] CR XEP| DISS.  THEN
;

: TRY-FIX DUP IS-F 0;
    @BBB @ TBI @ CONTAINED-IN 0; 
    BI^ TALLY:| DISS+ ;

: `TBB. TBI @ H. TBY @ H. TBA @ H. ;
: RESULT? AT-REST? DISS? AND   BAD? 0= AND ;
: BACKTRACK? 0;  
: BACKTRACK DROP DISS  \"BACKTRACKING_"
\ TBB. DISS? SPACES ."?_" DISS. \ CR
  >DEA
: REBUILD  !TALLY   DISS? 0;  DISS" !DISS STR| @+ XEP| |DROP
: TRYER   TRY-PI  TRY-FIX
: TRY-COMMA DUP IS-COMMA 0; @BBB CELL+ C@ TBY @
 CONTAINED-IN
\ "COMMA" DB2.
 0; BI^ TALLY:,, DISS+ ;

: AWORD: C: : Z, DOES> CR PUSH STARTVOC AHEAD BEGIN X: SWAP
 (IXEC  >DEA THEN DUP `IS-END  UNTIL  POP 2DROP ; \ SENTINEL

\ SHOW sift WORDS
: |WIDI DUP EX 0; DUP WID. 1L OVER VAL DEA?
 1+ CNTC + U< 0; CR ; 
AWORD: `SHOW-ALL |WIDI IS-OP    ; \ SHOW OPLIST
AWORD: `SHOW-PI  |WIDI IS-PI    ; \ SHOW IT
AWORD: `SHOW-FR  |WIDI IS-1FR   ; \ SHOW IT
AWORD: `SHOW-FI  |WIDI IS-1FI   ; \ SHOW IT
AWORD: `SHOW-,   |WIDI IS-COMMA ; \ SHOW IT

: .RESULT RESULT? 0; DISS-VECTOR  DISS- REBUILD ;
: SHOW-STEP  TRYER  .RESULT >DEA  BAD? BACKTRACK?
    CALL WHILE| BACKTRACK THEN DUP `IS-END DISS? AND ;
: `FSHOW "DUMP.TXT" >FILE \ SAVE SHOW: TO FILE
: `SHOW: !DISS   !TALLY DEA' DUP |2DROP UNTIL|
 SHOW-STEP DISS? 0= OVER `IS-END OR  ;


\ \ : MC@-S 2DUP MC<0 AHEAD
\ : GETFR CELL+ CURL - AHEAD
\ : GETMASK DXEP|   : GETCODE THEN CURL 
\ : MC@ 0 -ROT <ITER| C@ SWAP B* OR ;
\ 
\ : GETCODE?   XEP| AS-POINTER@  AHEAD
\ : INSTRUCTION  ISS@ ISL@    THEN
\ : AS-MC@ 0 -ROT  <ITER| AS-C@  SWAP B* OR ;
\ 
\ 0 VALUE LATEST-INSTRUCTION@
\ : COMPATIBLE? TBA @ OR BADPAIRS? 0= ;
\ : ADORN-ADDRESS DROP CR ;

: MC@-S 2DUP MC<0 AHEAD
: GETCODE?   XEP| AS-POINTER@  AHEAD
: GETMASK DXEP| 
: GETCODE THEN CURL THEN
: MC@ 0 -ROT 
: lsbytes <ITER|
: lsbyte@  C@ SWAP B* OR ;
: !INSTRUCTION CURL  TO ISL@  AS-POINTER@ TO ISS@ ;
: INSTRUCTION  ISS@ ISL@ MC@ ;
: GETFR CELL+ CURL - GETCODE ;

0 VALUE LATEST-INSTRUCTION@
: COMPATIBLE? TBA @ OR BADPAIRS? 0= ;
: ADORN-ADDRESS DROP CR ;

( ---------------- DISASSEMBLERS ------------------------ )

: DIS-PI DUP IS-PI 0; DUP >DATA @ AS-POINTER@ @ CONTAINED-IN 0;
   AT-REST?  0; \  ENABLE DEBUGGING IN DISASSEM
\  ENABLE DEBUGGING IN DISASSEM ( NEXT ROW )
\ DUP >DATA C@ $FF = TO IN-PI
\ IN-PI IF DUP 4+ DB. THEN
   @BBB GETMASK 
\ IN-PI IF AS-POINTER@ @ "GETMASK" DB2. DROP THEN   
   GETFR 
\ IN-PI IF "GETFR" DB. THEN   
   OR 
\ IN-PI DBG?   
   NOT
\ IN-PI DBG?   
   GETCODE?  
   AND 
\ IN-PI DBG?   
   OVER >DATA @ 
\ IN-PI DBG?   
   = 0;
\ IN-PI IF  "DIS-PI-OK" DB2.  THEN

   @BBB TALLY:, 
\ IN-PI IF  "TALLY:," DB. THEN
   
   DISS+ 
   DUP TO LATEST-INSTRUCTION@   `!HIDDEN?
    !INSTRUCTION     \ OLD ADDRESS TO ISS
: ADJUST-ADDRESS CURL AS-POINTER@ + TO AS-POINTER@
;

: DIS-FI DUP IS-1FI 0;
   @BBB  @ TBI @ CONTAINED-IN 0;
   BA^ C@  COMPATIBLE? 0;
   BI^ @  INSTRUCTION  AND OVER >DATA  @ = 0; 
\ IN-PI IF  DUP 4+  DB2.  THEN
   BI^ TALLY:|
\ IN-PI IF  "TALLY:|" DB. THEN
   DISS+
;

: DIS-FR
   DUP IS-1FR 0;
   @BBB  @ TBI @ CONTAINED-IN 0;
   BA^ C@  COMPATIBLE? 0;
   \ CELL# ISL@ - IF ? `DISF   
   
   BI^ GETFR 
   ISL@ CURL - LSHIFTB  
   INSTRUCTION  
   AND  \ MASKING FR BITS
   CELL# ISL@ - LSHIFTB 
\ IN-PI IF CR OVER H. DUP H. ."DATA>_" OVER >DATA @ H.
\ ."INST&>_" INSTRUCTION TBI @ AND H. 
\ OVER 4+  DB2. THEN
   OVER >DATA @ =  
   0;
\ IN-PI IF  DUP 4+  DB2.  THEN
   BI^ TALLY:|
\ IN-PI IF  "TALLY:|" DB. THEN
   DISS+
;

: DIS-COMMA DUP IS-COMMA 0;
   @BBB CELL+ C@ TBY @ CONTAINED-IN 0;
   BA^ C@  COMPATIBLE? 0;
\ CR DUP WID. ."OK-PI"
\ "DIS-COMMA1" DB2.
   BI^ TALLY:,,
\ "DIS-COMMA2" DB2.
   DISS+ ;
   
: |WID EX WID. ;   
: `|COMMA  VAL GETCODE? EX ADJUST-ADDRESS ;
: .DISS   DISS" STR| @+ XEP|  DUP |WID IS-COMMA 0;
: .COMMA   @BBB @ DUP PUSH 0<>; RDROP
: `.COMMA-STANDARD  `|COMMA U. ; 

: `|.()  ."(_" EX .")_" ;
: `(H) `|.() '$ MKID ID. ;

0#> C@ OVER 5+ C@ = SKIP 
: THERE?; WFIND IF DUP STARTVOC U< IF ] THEN DROP EXIT ;
?:, =PRIM?; '( ,   ?:, =LBL?; '@ ,  DROP
: .PRIMITIVE?  `RADR ODD 0<>; 
   `RADR 1+ THERE?;  =PRIM?;
   CR ."=P_" WID. CR 
;
: .LABEL? `RADR THERE?; =LBL?; 
: WE-STEPPED-ON $8000 OVER CELL+ OR!U
CR ."=L_" DUP @ SWAP WID. `(H) CR 
;

: `DODEF+  TO CURL !INSTRUCTION  
: .PRIMLAB
  .PRIMITIVE?
  .LABEL?
  AS-SPC  EMIT SPC  0 TO POINTER2 ;

: DEF|.HEX `DODEF+
: `|.HEX EX |TEST |CR 
 ;; \ CR
\  CR
     `|.() ISS@ DUP >RADR H. 
     AS-POINTER@ OVER- |SPC STR| CSTR VAL B. ;
\ : FND'? WFIND SWAP TO HLD IF STARTVOC U< ] 0 ; \ IS THERE ANY
: !IDC C@ ,< 0 VALUE IDC@
0#> !IDC |WID DUP WFIND IF DUP STARTVOC U< IF NIP ] THEN 
  DUP - OVER IDC@  MKID  (=: T ;
?:, ?MKLBL. '@ ,  
?:, ?MKID.  '~ ,  DROP
 
: `(S,) .PRIMLAB DEASMOF + AS-POINTER@ SWAP OVER-
 VAL SDUMP, TO AS-POINTER@ ;  

: `.COMMA-(RX) `|COMMA  DUP . 1+ 
: `.ADDRESS  `RADR 1+ + 
: `(H.) `|.() ."L'_" ?MKLBL. ;
\ : `(H.) `|.() '' EMIT SPC ?MKLBL. ;
: `.COMMA-(RB) `|COMMA BYTE>SIGNED  DUP . `.ADDRESS ;
: `(DB,) 1 DEF|.HEX [ ."DB,_" ]  
: `.COMMA-IMM  AHEAD  \ !HIDDEN? 
: `(DW,) 2 DEF|.HEX [ ."DW,_" ] 
: `.COMMA-SIGNED THEN `|COMMA DUP . `|.() '' EMIT SPC  ?MKID. ;
: `(DA,) 2 DEF|.HEX [ ."DA,_" ]
: `.COMMA-ADR `|COMMA DUP . `(H.) ;
: `.COMMA-SIGN-BYTE `|COMMA BYTE>SIGNED . ;

: `D-F ( : FalsE-DISASSEMBLY )  |AS-SPC
  [ TO AS-POINTER@ ] AS-POINTER@ XEP|
: `DDD  : `(DISASSEMBLE)   !DISS !TALLY STARTVOC
: `((DISASSEMBLE)) !INSTRUCTION .PRIMLAB BEGIN 
    DIS-PI DIS-FI DIS-FR DIS-COMMA       >DEA \ TO NEXT IN LIST
    DUP `IS-END RESULT? OR UNTIL  DROP RESULT? IF 
    `|.HEX  .DISS ] \ Advances pointer past commaers
: SHOW-MEM  ISS@ TO AS-POINTER@
    UNTILZ|  `(DB,) `RADR I-ALIGNMENT UMOD ;

: `DIZABY ( DISASSEMBLE-NEXT BYTES ) `RADR SWAP
: `D-S ( DISASSEMBLE-STRING ) OVER+  !AS-SPC 
: `D-R ( : DISASSEMBLE-RANGE START-ADDRESS END-ADDRESS ) 
     SWAP DEASMOF + TO AS-POINTER@ 
: `DT ( DISASSEMBLE-TO BY INSTRUCTIONS )  DEASMOF + |DROP
   CALL WHILE|  `(DISASSEMBLE) THEN AS-POINTER@ OVER U< ;

: `DTA ( DISASSEMBLE-TO BY WPRDS )  DEASMOF + |DROP
   CALL WHILE|  `(DA,) THEN AS-POINTER@ OVER U< ;

: `CODE !TALLY CSP! ;   : `;CODE ?CSP CHECK26 CHECK32 ;

: ADZAS   POINTER2 AS-POINTER@ `D-R ;
ADR'  ADZAS TO IMMTEST 


EXPORTED `SHOW-ALL SHOW-ALL
EXPORTED `SHOW-PI  SHOW-PI 
EXPORTED `SHOW-FR  SHOW-FR 
EXPORTED `SHOW-FI  SHOW-FI 
EXPORTED `SHOW-,   SHOW-, 
EXPORTED `SHOW:    SHOW:
EXPORTED `FSHOW    FSHOW
EXPORTED `TB^      TB^
EXPORTED `D-F      DDF
EXPORTED `DDD      DDD
EXPORTED `D-S      D-S
EXPORTED `DIZABY   DIZABY
EXPORTED `DT       DT
EXPORTED `D-R      D-R
EXPORTED `COMMAER           COMMAER
EXPORTED `.COMMA-STANDARD   .COMMA-STANDARD
EXPORTED `.COMMA-(RX)       .COMMA-(RX)
EXPORTED `.COMMA-(RB)       .COMMA-(RB)
EXPORTED `(S,)              (S,)
EXPORTED `(DB,)             (DB,)
EXPORTED `.COMMA-IMM        .COMMA-IMM 
EXPORTED `.COMMA-SIGNED     .COMMA-SIGNED
EXPORTED `(DA,)             (DA,)
EXPORTED `(DW,)             (DW,)
EXPORTED `.COMMA-ADR        .COMMA-ADR
EXPORTED `.COMMA-SIGN-BYTE  .COMMA-SIGN-BYTE
EXPORTED `TBB.     TBB.
EXPORTED `DEZOBJ   DEZOBJ
EXPORTED `DEZORG   DEZORG
EXPORTED `1PI      1PI
EXPORTED `2PI      2PI
EXPORTED `1FI      1FI
EXPORTED `1FR      1FR
EXPORTED `CODE     >CODE
EXPORTED `;CODE    ;CODE
EXPORTED `ENDER    ENDER
EXPORTED `DTA      DTA

RETURN`
PRUNEM
