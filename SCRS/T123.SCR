BB 00 10 B4 4A CD 21 BC FE FB BE FE F7 E8 1E 000123456789ABCDEF 00 00 00 00 00 00 00 00 52 87 E6 5F 87 FB 59 5A                 56 FF D7 5E 52 51 53 50 1B C0 87 E6 5A 5F 5B EB                 63 59 49 51 78 0A 8B 1F EB 5A 0B C0 AD 72 F7 90                 43 43 EB 50 EB EB D1 24 D1 D0 3B C2 72 04 2B C2                 FF 04 EB DA 8B 0C D1 E9 73 02 03 C2 D1 D8 D1 1C                 EB CC 5F 97 EB 0B 91 AD 23 C1 F7 D0 EB 26 5F 87                 FA 57 EB 20 57 3C 50 AD EB 1A 5F AB EB F6 5F 8B                 0D AF EB 03 5F 59 51 57 EB 04 59 3D 8B C8 8D 74                 FE 89 04 91 8B 3F 43 43 D1 E7 72 03 FF E7 5F 53                 8B DF EB F0 91 AD 33 C1 EB EA 03 04 89 04 D1 D8                 EB E2 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                                                                                                                                                                                                                                                                 \ PAGE  AT HANDLES  DUP 2+ SWAP!                                \ EXIT   2 LOAD  57 LOAD  20 LOAD  70 LOAD                      : + + ;                                                         : PROBA + ;; ;                                                                                                                                                                                    : CLARY HERE OVER ERASE ALLOT ;                                 : ZARY,  HERE DUP PUSH 2- EXEC POP - CLARY ;                    : -USE SCRH 1+ 0; SCRH FClose -1 TO SCRH ;                      : USING FLUSH -USE FNAME FOPEN TO SCRH ;                        : BYE CLOSE-ALL FLUSH -USE (BYE ;                               : FLUSH SAVE-BUFS EMPTY-BUFS ;                                                                                                                                                                                                                                                                                                -1024 VALUE THERE : <H HERE THERE TO HERE TO THERE ; ' <H =: H> : `SOURCE BLK ETIB 0?SKIP NIP; DUP 0; BLOCK 1K + DUP TO ETIB ;  META `SOURCE SOURCE                                                                                                             D0 2  FAMILY VALUE `PDATA `INS                                  0 VECTOR `'ADVANCE              : PAGE 0 24 @XY PAGE ;          : L/ 1L NEG AND ;    { LINE BEGIN FUNCTION }                    : ?EXIST; LOCATE 0= 0?SKIP DROP; RDROP                          : \ BLK IF LTIB 1- L/ TO LTIB ;THEN ,< ,' \` >, ;  ' \ =: \`    : <? 2DUP : < - 0< ;            : >SORT <? 0; SWAP ;            : MIN >SORT NIP; ,<             : MAX >SORT DROP; ,<            : BACK3 POP 6 - PUSH ;                                          0 VALUE DPTR  0 VALUE ADR  0 VALUE NPTR                         : DNEXT DPTR CSTR + @+ TO NPTR ;   : END? DUP TO DPTR C@ ;                                                                                                                                      \  2 LOAD  \ INIT                                               \ 57 LOAD  \ WORDS                                              \ 20 LOAD  \ PRUNE  FORGET SAVE ...                             \ 70 LOAD  \ EDIT                                                                                                               \ COPY BLOCKS                                                   : COPIES ;RANGE LOOPS DXEP+                                     : COPY BLOCK SCR DUP 1+ TO SCR BLOCK 1K CMOVE UPDATE FLUSH ;                                                                     116 121 COPIES                                                                                                                                                                                                                                                                                                                                                                                                                                                 { NVF2 INI }                                                    { $1221 IS SOURCE }                                             { -1 TO SCRH}                                                   { EMPTY-BUFS}                                                   { USING T123.GGG}                                               META @OK vOK.                                                   META (ERR vERR                                                  META (AC ACCEPT                                                 META (BE EMIT                                                   ' (BK TO KEY                                                    PAGE                                                            { AT HANDLES  DUP 2+ SWAP! }                                                                                                                                                                                                                                                                                                    : <ID? ADR 2- : #>ID? TO ADR CALL C@ ;THEN                             0;LIST ADR <> #IF NIP; THEN SWAP HERE ! ;                : `ADDLP ;DROP 0;LIST  ADR U< 0;  DUP  1+ C@ '` XOR 0;           DUP  J OVER - HERE STR + OVER  HERE+! SWAP 1+ CMOVE ;          : `P TO ADR `ADDLP 1 HERE+! ;                                   : FORGET '                                                      : FGT `P $E000 TO DICT HERE STR >DICT ADR TO HERE ;             : PRUNE HERE FGT ;                                              : ?ID. CALL ID. HERE @ ID. SPACE ;THEN                                 #>ID? IF @R+ DROP; THEN    <ID? IF " TO" ;THEN                   <ID? IF " AT" ;THEN RDROP ." `$" ADR 2+ 2+ H. ;                                                                                                                                                                                                                                                                                                                                         CREATE `O $39D , $140 , $38B , $1AE , 0 VALUE `H  0 VALUE `HNDL : `;HNDL<> HANDLES TO `HNDL EX `HNDL TO HANDLES ;               : `N, LOOPS : `W, STR : `, `H !+ TO `H ;     : `W+, `W, 2+ ;    : `WS, `W, : `S, SWAP : `WS+, `W, SWAP 2+ ;                                                                                                      : `INIT $100 TBL TO `H  7 `N, `O  `WS+,          `WS, `WS, `W+, 0 `, `W+, 0 `, 12 `N, `S, NIP 2 `N,  ADR `, 2+   8 `N, DROP $E000 `,  TBL `H                                   : `OVER-FWR OVER - : `FWR `HNDL FWRITE ;                        : SAVE TOKEN? FCREATE ;FILE  `;HNDL<>                                   `P  `INIT  $152 ADR `OVER-FWR  HERE DUP @ 2+ `FWR ;                                                                                                                                     { $38B =: (ACC   $39D =: (DE    $140 =: ETIB    $1AE =: @_INI}                                                                                                                                  { INIT TO START VALUES }                                        : SHN3 CR SHN3 ;                                                SHN3 : 1+DXEP 1+ : DXEP DUP : XEP XCHG EXECUTE POP ;            SHN3 : PLACEBLOCKS PUSH 1- POP ;DROP OVER - LOOPS 1+DXEP        : PLACEBLK  { @ADR BLK }   BLOCK OVER 1K CMOVE 1K + ;           META (ACC ACCEPT                                                META (DE EMIT                                                   HERE 30 55 PLACEBLOCKS    SHN3                                                                                                  HERE SWAP OVER -   $170 EXECUTE                                                                                                                                                                                                                                                                                                                                                                                                                                 \ FILE TO BLOCKS CONVERTER      \ MARKER F2B.                                                                                   : `?ADDLINE  PUSH I XY + LIT ,< 1K 1L - , >,   U< 0=             IF SCR 1+ DUP TO SCR BUFFER 1K BLANK UPDATE 1L TO XY THEN       SCR BLOCK XY + I CMOVE POP XY + 1L 1- OR 1+ 1K 1- AND TO XY ;                                                                  : F2B  TOKEN?  : "F2B FOPEN ;FILE  \ TO BLOCKS POINTED BY SCR     1K TO XY  NPAD CSTR  SKIP        \ PREPARE TO SAVE FILE NAME    BEGIN  vINIT  `?ADDLINE EOS?  UNTIL FLUSH ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   \ FILE TO BLOCKS CONVERTER                                      : `?ADDLINE  DUP PUSH XY + LIT ,< 1K 1L - , >,   U< 0= IF         SCR 1+ DUP TO SCR BUFFER 1K BLANK UPDATE 1L TO XY  THEN         SCR BLOCK XY + I CMOVE POP XY + 1L 1- OR 1+ 1K 1- AND TO XY ; : F2B  TOKEN?                                                   : "F2B FOPEN ;FILE              \ TO BLOCKS POINTED BY SCR        1K TO XY  NPAD CSTR  SKIP     \ PREPARE TO SAVE FILE NAME       BEGIN  vINIT  `?ADDLINE EOS?  UNTIL FLUSH ;                                                                                                                                                                                                                   EXIT                                                            : (,) 0SWAP : (T) =HT  Z, , , DOES> <MRK  DUP 2+ DUP INC @ 0<    (IF MRK> PUSH HERE @I , POP ! EXIT RLS> @ A, ; 3  - IS #TARGET                                                                                                                                 \ $CC00 $1400  $178 EVAL                                        \ BLOCKS TO FILE  CONVERTER                                     \ MARKER B2F.   : SHORT? DUP -$80 $80 WITHIN ;                                                                                  LIKE 2DROP; 1+  =: 2DROP  0 QUAN `OCBUF   0 VALUE `OHNDL        : FEMIT TO `OCBUF  AT `OCBUF 1  : FWR  `OHNDL  FWRITE ;         : ;OFILE TO `OHNDL  LIT TO EMIT  XCHG I @ PUSH LIT FEMIT J !         PUSH EX POP POP ! `OHNDL FCLOSE ;                          \ : ;PREP_BLKS PUSH 1- POP OVER - : ;DROP EX DROP ;             : TRIM< FOR DUP I + C@ bl = IF  CSWAP> NEXT 0 ;THEN POP 1+ ;    : B2F  TOKEN? : "B2F FCREATE ;OFILE   \ FROM BLOCKS             : B2S { ;PREP_BLKS} ;RANGE LOOPS DXEP+ : LIST BLOCK             : .BLOCK 1H ;DROP LOOPS DUP 1L + XEP                            : .LINE 1L : TRTYPE TRIM<  : WRITELN TYPE CR ;                  : INDEX ;RANGE LOOPS DXEP+ J U. BLOCK .LINE ;                                                                                   ' , 3 OPER[] ! $269 =: NUM?  : HP HERE 2+ ; : @=, STR =, ;      $E7B IS SOURCE  META @OK vOK.  META (BE EMIT META (AC ACCEPT    PAGE META (ERR vERR : ;A, EX : A, 3 OPER[] @EXEC ; $3A9 =: (FND : DOES, 0 : DOES- #DOES SWAP - : CALL, $E8 C, : ,R HP - , ;     HERE DOES, >, C@ HERE SWAP DOES- >, ; DUP DUP =, 0]> 0 C,        =, 1]> 1 C, =, 2]> 2 C,  : (@R @R+ J + @ ; : (!R @R+ J + ! ;   0]> : `T @ ' + ; : >NUM TOKEN? NUM? ; 1]> `T A, ; 2]> `T EXEC ; =, TO  =, TO`  =, 'TO 2 , ' TO @=, AT @=, AT` @=, 'AT 4 , DROP  LIKE 2DROP; 1+ =, 2DROP $247 =: RDROP  : COMPILE @R+ A, ;       : ;Z, EX : Z, 0 : <RLS` , ; : RLS>` HERE  SWAP! ; : MRK>` HERE   Z, ; : <MRK` HERE ;  : @I J @ ; : 0SWAP 0 SWAP ; : !I J ! ;                       ' HERE @=, THERE @ , HP ,                    $8000 TO HERE 0 , : TARGET-SPACE ;  11 TO BLK  ' (BK TO KEY         12 14 THRU                  0 TO BLK    CR .( OK2)   CR                                                                                                                                      HERE THERE TO HERE TO THERE : ;NAME> EX : NAME> CSTR + ;       : ;DICT DICT EX TO DICT ; : TOKEN+ TOKEN? DUP : INC ;@! 1+ ;    : @R` COMPILE (@R : ,NUM? >NUM DUP ODD ?? , ; : CFA? TOKEN+     : IFIND 1 DICT (FND ; : !R` COMPILE (!R ,NUM? ; : W, ;A, STR ;  : RECURSE` ;A, : LATEST DICT : N>C NAME> @ ; : WAS ' 2+ @ ;     : PLACE OVER C@ 1+ CMOVE ; : `;code POP : TOBE LATEST ! : NOP ; : (S" (ASTR DROP ; : SUCSTR SWAP XEP CSTR ; : (: =H : ;, EX , ; LIKE ;` =, DOES>` >, `;code DOES, ,< : <>0; (IF MRK> RDROP RLS> ; : LINK? PUSH @R 2 DUP 2+ !R 2 XCHG POP ODD ; : @, NOP @ , ;   : ALIGNED ;HERE : ALIGN DUP ODD + ; : ;>DICT EX .C@ 1+ >DICT ;  : =HT HERE : =:T TOKEN+ : =:NAME ;>DICT XEP : DICT!- ;DICT !- ; : (,) 0SWAP : (T) =HT  Z, , , DOES> <MRK LINK? (IF TO @,        : LINK, PUSH HERE @I , POP ! ;  LIKE bl (,) (CON ' LIT (,) (LIT : CONST (: (CON` ;  3 - CONST #TARGET   ' KEY 2+ 2+ @ (,) (VAR  ' (LIT` IS #,`  0]> { NEW#,} PUSH @R+ EXEC POP @EXEC ;  ' #,` !                                                                 : VAR (: (VAR` ;        LIKE vERR (,) (DEF  WAS HERE  (,) (SET   LIKE HERE (,) (CON2    : '(, ' : DEFER (: (DEF` ;              : VALUE (: (CON2` (SET` ; ' HANDLES STR (,) (STK>  @ (,) (>STK  LIKE vERR  1- (,) (DEF2      : VECTOR (: (DEF2` (SET` ;         : STACK (: (STK>` (>STK` (VAR` TUCK , , ; : [ID] ;SPC ;[] ". ;  0 VECTOR vDO : `AT@ ' TO vDO POP ; : DO `AT@ vDO ;              : ZDO `AT@ 0 vDO ; : 'DO `AT@ ' vDO ;  : #DO `AT@ >NUM vDO ;    : +DO `AT@ DUP vDO : OVER+ OVER + ;                             'DO VECTOR 4 TIMES  TOKEN? vTOK?  2- vIS:?  2+ vTOC>. 0 v.>TOC  ZDO VALUE 5 TIMES T-LO T-HI >LTIB< >CFA< ^. : EXI?T ;GO TO <>0; : EXIST? LTIB TO >LTIB< TOKEN? IFIND SWAP TO >CFA< ;            : SAME? TBUF EXIST? 0; TBUF [ID] : ?BLK. BLK 0; : BLK. BLK . ;  ' vTOK? $289 !  ' SAME? TO vTOK? : T> 0 : `<T> TO T-HI : <T>     HERE THERE TO HERE  TO THERE ; : ;T><  T> EX : <T $8000 `<T> ; : CREATE  0 VAR : H- ;DROP : @H- ;HERE @- ;                                                                                      229 236 THRU   \ MAIN COMPILER                                 : E 0 TO BLK E ;                                                  237  LOAD      \ DEBUGER                                                                                                        EXIT                                                                  15 LOAD   \ TARGET DEBUGGER                             \ EXIT                                                             145     LOAD                                                    146 150 THRU   \ TARGET COMPILER                                                                                                240 248 THRU                                                                                                                    CR CR .( TOTAL ) HERE $2000 - . .(   BYTES) CR CR                                                                            \ : T1 CALL THEN : T2 NOP ;                                                                                                     #DO VALUE 6 TIMES  $20B2 T-MID  0 OPA  0 vA  0 N  0 :ID  0 TOK  : `;TYPE  DUP 1H - 1H SPACE ;[] TYPE ; : 'T CFA? #?? 2+ @ 2* ;  : WDUMP bs ?DU ;DROP LOOPS CR DUP H. SPACE bs LOOPS STR H. ;    : DUMP 1H ?DU ;DROP : DU LOOPS CR DUP H. SPACE `;TYPE :;          1H LOOPS CSTR B. ; :  ;^  ^. EX TO ^. ; : ^+ ;^ STR TO OPA ;  : .REM  :ID 0; ." { " :ID  ".  ." }" ;  : T>A 2* ;  143 LOAD    : A>T? OPA RANGE?  OPA ODD 0= AND ;   : `CR-H CR : .HL ^. H. ;  : >A!T TO OPA : A!T 0 TO TOK  A>T? 0;  [ TO TOK ]                OPA : >TOK T-MID U< 0=  IF [ $8000 XOR ] THEN 2/ ;             : =/NULL? J TO N  STR 2+ @ #IF OPA - ;THEN 1+ ;                 : OPSCAN CSTR FOR  =/NULL? EXIT ?; NEXT DUP XOR ;               : >LOOP 1- DUP 0< IF DROP EXIT ;THEN I 2- XCHG PUSH ;                                        16 LOAD  17 LOAD                                                                                                                                                                                                                   : :ID? >A!T TOK 0; TOK B>N? TO :ID DROP ;                       : `:ID? ^.  :ID?  :ID 0;  `CR-H ." : " : OP. :ID ID-. ;         : ``CN 1- B>N?  : ``N EXIT ?; POP ID.  ID-. EXIT ;              : ``TO. ``CN ,< ,T 1TO  : ``AT. ``CN ,< ,T 1AT                  : ```CN 2- :ID?  ``N ;                                          : ```TO. ```CN ,< ,T 2TO   : ```AT. ```CN ,< ,T 2AT                                                                             : ?ID. B>N? 0= ID-. ?;   ``TO.  ``AT.  2+                                               ```TO. ```AT.  4 + ?ID. ;               : ASTR OP. ;^ DUP  [ID] NAME>  ALIGN ;                          0]> STR TO vA OPSCAN 0; vA EXIT ;                               DUP =,  ?STR ,' ASTR  3  C, >, (A"`  ("` (."` ,<                                                                                                                                                                                                                                                                                : 1. OP. ^+ OPA H. ;                                            : IS-JMP ^. @ ^. U< 1. ?; ." WORD;" ^+ ;                        : IS-IF 1. ;                                                    : AJMP N IS-IF ?;  N 1- IS-JMP ?; 1. ;                          =,  ?JMP ,' AJMP 6 C, >, ;GO` (#IF` (NXT` (OF` (JMP` (IF` ,<    \ CCVBNC                                                         EXIT                                                           : ?WD  ?JMP  ?STR OPA ?ID. ;   : SEE 'T : @SEE TO ^.            : L bs LOOPS : WW `CR-H ^+ OPA H. : `W0 ?WD  ;;                 : HACK 'T : @HACK TO ^. : HL CR bs LOOPS `:ID? ^+ `W0 ;         : -HL ^. 23 - @HACK ;                                                                                                                                                                                                                                                                                                                                                                                                                                           DO .STAT 20 TIMES   (#IF  (OF  (CON  (LIT   (VAR                  (DEF  (SET  (CON2  (STK>  (>STK  (DEF2  (DEF3  (SET2            (CON3  (EMT  ("  (A"  (."  (S"  ;GO                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           \ SELF PRUNE SCREEN  \ <H HERE 5 LOAD FGT H>                    { PRUNE BY ADDRESS}  : `HERE+! HERE  DUP PUSH @ + POP ! ;       : `DICTEL DPTR NPTR OVER - ; : `DEST HERE STR + ; 0 VALUE `H    : `ADD? DNEXT  ADR U< 0;  DPTR 1+ C@ '` XOR 0; `DICTEL `DEST     OVER `HERE+! SWAP 1+ : `CMOVE ;2DROP LOOPS PUSH CSTR POP C!+ ; : `P TO ADR   0 HERE !  DICT SKIP BEGIN  NPTR  END? WHILE         `ADD? REPEAT 1 `HERE+! ;  CREATE `O >, (DE ETIB (ACC @_INI ,< : FORGET ' : FGT `P $E000 TO DICT HERE STR >DICT  ADR TO HERE ; : `N, LOOPS : `W, STR : `, `H !+ TO `H ; : 'PRUNE ' 2+ @ FGT ;  : `WS, `W, : `S, SWAP : `WS+, `W, SWAP 2+ ; : PRUNE HERE FGT ;  : `W+, `W, 2+ ;  : `INIT $100 TBL TO `H  7 `N, `O  `WS+,          `WS, `WS, `W+, 0 `, `W+, 0 `, 12 `N, `S, NIP 2 `N,  ADR `, 2+   8 `N, DROP $E000 `,  TBL `H                                   : `OVER-FWR OVER - : `FWR FHTOP FWRITE ; : SAVE TOKEN? FCREATE    ;FILE `P  `INIT  $152 ADR `OVER-FWR  HERE DUP @ 2+ `FWR ;                                                                     $1AC =: DROP;   $1EA =: DUP     $1FD =: ,<`     \ NF7.NVF       $13A =: HERE    $3E2 =: !       $235 =: ;`      $10C =: EMIT    $22F =: :       $27D =: =,      $215 =: C@      $273 =: ;HERE   $1FF =: 3+      $152 =: CNTC    $14C =: DICT    $118 =: vOK.    $424 =: C!+   : C, ;HERE C!+ ;  $209 =: +       $207 =: -       $259 =: ,       HERE  $4B C,   HERE  $4B C,  $EB C,  $4F4 2 +   HERE 1 + - C,  =, 1-  =, 2-     $2BB =: #??     $3FE =, AND     $299 =: TOKEN?  $221 =: FIND    : LOCATE TOKEN? FIND 1 AND ;    : ' LOCATE #?? ;  : LIKE ' @ ;  $48B =: >,      $29D =: WORD    $48D =: #DOES   $1F8 =: @                                       HERE $E8 C, #DOES HERE 2 + - ,  >, C@ WORD DROP; ,<             DUP =, \ 0 C,  =, { '} C,                                       : ,' ' , ;                                                      $24B =: SKIP    $1A8 =: ;DROP   $245 =: (NEXT   $4B1 =: (FOR    $444 =: PUSH    $47F =: EXECUTE $241 =: J       $20B =: STR                                                                     $1DD =: (ASTR   $219 =: CSTR    $247 =: RDROP   $253 =: POP     $194 =: (A"     $1C2 =: ;DPUSH  $11C =: vERR    $1C4 =: >DICT   $128 =: TBUF    $24D =: ABORT   $158 =: STATE   $212 =: .C@     $27F =: =H      $487 =: @EXEC   $12C =: 0       $2BD =: ??      $39D =: (DE     $1AE =: @_INI   $4E6 =: ABS     $261 =: NUM,    $38B =: (ACC    $114 =: ACCEPT  $23B =: #,`     $2D0 =: (,EX    $257 =: ;COMMA  $4B8 =: 0?SKIP  $29B =: TOKEN   $1E5 =: XCHG    $2B1 =: ;SETSTR $2B9 =: ;TOK?   $4EF =: 0=      $130 =: bl      $269 =: NUMBER  $102 =: OPER[]  $205 =: OVER    $33E =: (PARS   $29F =: PARSE   $1D7 =: @R+     $110 =: SOURCE  $42A =: !+      $4C2 =: (#IF    $201 =: SWAP    $120 =: TBL     $124 =: TIB     $140 =: ETIB    $178 =: EVAL    $251 =: EX      $483 =: EXEC    $24F =: EXIT    $3A9 =: (FND    $4C8 =: (IF     $134 =: vINIT   $249 =: (JUMP   $146 =: LTIB    $36D =: (MPUSH  $1F2 =: LIT     $203 =: DROP    $37A =: (S!     $255 =: NIP;    $362 =: (NUM                                                                    $4AD =: `_BARY  $2DA =: `_COMMA $40C =: `_CONS  $40B =: `_CONS2 $1CE =: `_DROP  $448 =: `_DUP   $4A9 =: `_LARY  $405 =: `_IJ    $42F =: `1P_NIP $4E3 =: `1P     $462 =: `2DROP  $4EB =: `NOT    $48F =: `DOES3  $182 =: `DOEVAL $3A2 =: `DOS_DX $4F4 =: `CF     $3FA =: `ADD    $411 =: `ADR    $491 =: `DOES   $490 =: `DOES2  $42E =: `2P_NIP $4E1 =: `3P     $1AA =: `ABORTX $165 =: `ABORT  $2DF =: `_MAKER $4A0 =: `_POINT $434 =: `_RLD@  $439 =: `_RST@  $496 =: `EX     $472 =: `EXEC   $4CA =: `IF     $4CF =: `JUMP   $4CC =: `JUMPDR $498 =: `LBL    $21C =: `LDB    $49A =: `MAIN   $16E =: `MAINLP $4EA =: `NEG    $497 =: `NEST   $47D =: `NEST2  $41D =: `DROP   $416 =: `DROPX  $461 =: `2DROPX $4E2 =: `2P     $47A =: `NEST5  $4D3 =: `NEXT   $41F =: `NIP    $431 =: `NIPX   $2E6 =: `NUM    $3F1 =: `OVER   $3F2 =: `POP    $441 =: `PUSHW  $3EC =: `ROT    $4BF =: `SKIP   $3F8 =: `SUB    $4DB =: `SWAP   $4DA =: `SWAPX  $401 =: `XOR    $3E7 =: `_1M    $3E6 =: `_2M                                                                    $1D1 =: `TOPDROP        $1EC =: `TOPDUP        $386 =: `PUSH_DC $499 =: `RETURN         $1CF =: `SETDROP       $4BC =: `SKIPDR  $3AE =: `PUSH_SC        $440 =: `PUSHW2        $43F =: `PUSHW3  $450 =: `_PARAM1        $453 =: `_PARAM2       $456 =: `_PARAM3 $2C9 =: `_STATE         $3E8 =: `_TOP?         $3F5 =: `_VAR2   $4A5 =: `_SETPNT        $41B =: `_SETVAR       $44B =: `_CALL   $41A =: `_SETVAR2       $419 =: `_SETVAR3      $468 =: `_DEFERO $470 =: `_DEFER         $46F =: `_DEFER2       $40A =: `_CONS3  $47C =: `NEST3          $47B =: `NEST4         $4DE =: `RDROP   $46E =: `_DEFER3        $3F4 =: `_VAR3         $4AB =: `_WARY   $40E =: `_VAR           LIKE ;` =, :` ,' SKIP ,' :              ' `2P  =, 2+            ' `1P  =, 1+  \ : C,R HERE 1+ - C, ;    HERE $E8 C, #DOES HERE    2+ - , >, C@ C, ;                     DUP =, #CAL, $E8 ,    DUP =, #JMP, $E9 ,    DUP =, JMPS, $EB ,  =, RET, $C3 ,                                                                                                                   : DOES, #DOES           : CALL, #CAL,   : ,R HERE    2+ - , ;   : CODE: HERE 2+ =, ; LIKE ! =, U< $2B C, $DF C, #JMP, ' `CF ,R  CODE: 0<  $D1 C, $E3 C, #JMP, ' `CF ,R        LIKE DUP =, U/MOD $33 C, $C9 C, $91 C, $92 C, $F7 C, $F3 C, $93 C, $91 C, RET,    LIKE DUP =, SM*  $93 C, $F7 C, $EA C, $92 C, $93 C, RET,        LIKE DUP =, UM*    $93 C, $F7 C, $E2 C, $92 C, $93 C, RET,      ' `NEG =, NEG   ' `XOR =, XOR  ' `NOT =, NOT                    : 2* DUP + ;    : * SM* DROP; ,<        : U* UM* DROP; ,<                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       56 CONST .1  0 VALUE THERE                                      : <H HERE THERE TO HERE TO THERE ;  : ;CR EX : CR 13 EMIT 10      EMIT ; META ETIB SOURCE LIKE J =, I 0 ,   LIKE ! =, U<           $2B C, $DF C, #JMP, $4F4 ,R  LIKE DUP =, U/MOD               $33 C, $C9 C, $91 C, $92 C, $F7 C, $F3 C, $93 C, $91 C, RET,    : TWICE I PUSH ; : ??, HERE OVER U< A" UPPER MEM! " , ;         : ;[] '[ EMIT EX '] EMIT ; : @OK ;[] CR ; \ META  @OK vOK.      : LOOPS FOR  J EXECUTE NEXT RDROP ; : ;SPC EX : SPACE bl EMIT ; $3FE =, AND  $3EC =, ROT  : (CALL @R+ PUSH ;  3 : SHN3 CR #,      LOOPS ROT DUP : H. 256 U/MOD  CALL : B. ;SPC  THEN              255 AND 16 U/MOD TWICE 9 OVER U<  7  AND + '0 + EMIT ;        1 : 1+ #, + ;  : S-. SWAP - H. ;  16 CONST 1H                   : (ERR CR ;CR LTIB 1024 U/MOD OVER IF 1+ THEN .1 S-.             1024 S-. STATE TBUF  TWICE ;SPC CSTR : TYPE ;DROP              : ?T LOOPS CSTR DUP 32 U< IF DROP '. THEN EMIT ;                \ META (ERR vERR                                                HERE H.  META ETIB SOURCE  ETIB TO HERE CR    HERE H.                                                                           : ??, DUP  $4F8  ETIB WITHIN A" OVERLAP MEM! " , ;              ' ??,  3 OPER[] !                                                                                                                 : ;SPC EX : SPACE bl EMIT ;  $1A8 =: ;DROP                    : ;[] SPACE '[ EMIT EX '] EMIT ; 16 CONST 1H  LIKE J =, I 0 ,   : TWICE I PUSH ;  LIKE ! =, U< $2B C, $DF C, #JMP, $4F4 ,R       $3FE =, AND  $3EC =, ROT  1 : 1+ #, + ;      LIKE DUP =, U/MOD $33 C, $C9 C, $91 C, $92 C, $F7 C, $F3 C, $93 C, $91 C, RET,    : LOOPS FOR  J EXECUTE NEXT RDROP ; : CR 13 EMIT 10 EMIT ;      : B. ;SPC : (B. 255 AND 16 U/MOD TWICE 9 OVER U< 7 AND + '0 +    EMIT ; : ;NIP EX : NIP SWAP : DROP DROP; ,< : ;T EX DUP 1H -   1H ;[] : TYPE ;DROP LOOPS CSTR DUP 32 U< IF DROP '. THEN EMIT ;                                                                                                                                    : UN? ;NIP : ?U U/MOD OVER IF 1+ THEN ;                       3 : SHN3 CR #, LOOPS ROT DUP : H. 256 U/MOD (B. B. ;           : DUMP 1H UN? ;DROP LOOPS CR DUP H. SPACE ;T 1H LOOPS CSTR B. ;                                                                 : S-. SWAP - H. ; : (ERR CR LTIB 1024 ?U ,< 55 1+ >, #,           S-.  1024 S-. STATE TBUF  TWICE CR ;SPC CSTR TYPE ;           : @OK ;[] CR ; META  @OK vOK.  META (ERR vERR                   0 VALUE THERE    : ??, HERE OVER U< A" UPPER MEM! " , ;         3 : OP! @R+ #, OPER[] ! HERE THERE TO HERE TO THERE ;                                : H> OP! ??, ; : <H OP! , ;                HERE TO THERE  CR  THERE H.                                     ' <H ' H> ' DUMP ' SHN3 ' H. ' B. ' TYPE ' THERE $100  !-       !- !- !- !- !- !- !-  ' STR ' TO FORGET C, =: TO  $DFFA TO DICT  =: STR  STR =: <H   STR =: H>  STR =: .D  STR =: .S                     STR =: .H   STR =: .B  STR =: .T  STR =: THERE  .H                                                                     $102 =: OPER[]  $10C =: EMIT    $110 =: SOURCE  $114 =: ACCEPT  $118 =: vOK.    $11C =: vERR    $120 =: TBL     $124 =: TIB     $128 =: TBUF    $12C =: 0       $12E =: BYE     $130 =: bl      $134 =: vINIT   $13A =: HERE    $140 =: ETIB    $146 =: LTIB    $14C =: DICT    $152 =: CNTC    $158 =: STATE   $178 =: EVAL    $194 =: (A"     $1A8 =: ;DROP   $1AC =: DROP;   $1C4 =: >DICT   $1D7 =: @R+     $1DD =: (ASTR   $1E5 =: XCHG    $1EA =: DUP     $1F2 =: LIT     $1F8 =: @       $1FD =: ,<`     $201 =: SWAP    $203 =: DROP    $205 =: OVER    $207 =: -       $209 =: +       $212 =: .C@     $215 =: C@      $219 =: CSTR    $221 =: FIND    $22F =: :       $235 =: ;`      $23B =: #,`     $241 =: J       $245 =: (NEXT   $247 =: RDROP   $249 =: (JUMP   $24B =: SKIP    $24F =: EXIT    $251 =: EX      $253 =: POP     $255 =: NIP;    $259 =: ,       $273 =: ;HERE   $27D =: =,      $27F =: =H      $299 =: TOKEN?  $29D =: WORD    $2BB =: #??     $2BD =: ??                                                                      $36D =: (MPUSH  $37A =: (S!     $39D =: (DE     $3E2 =: !       $424 =: C!+     $42A =: !+      $444 =: PUSH    $47F =: EXECUTE $48B =: >,      $483 =: EXEC    $487 =: @EXEC   $48D =: #DOES   $4B1 =: (FOR    $4B8 =: 0?SKIP  $4C2 =: (#IF    $4C8 =: (IF     $4E6 =: ABS     $4EF =: 0=                                      <H H>           $4E3 =, 1+      $4E2 =, 2+     : C, ;HERE C!+ ; <H : C,R HERE 1+ - C, ; H>                                      HERE $4B C,     HERE $4B C, $EB C, $4F4 2+  C,R  =, 1-  =, 2-   $3FE =, AND     $401 =, XOR     $4EA =, NEG     $4EB =, NOT     : { '} WORD DROP; ,<                                            : @+ STR SWAP ; : SWAP! SWAP ! ;                                : LOCATE TOKEN? FIND 1 AND ;    : ' LOCATE #?? ;   : LIKE ' @ ; : ,' ' , ;      LIKE ;` =, :` ,' SKIP ,' : { DEFINE ON COMPILE} : BE ' ! ;      : META '        : IS ' 2+ ! ;   ' XOR =: <>                                                                                                                                     $40E =: `_VAR   $40C =: `_CONS  $3F4 =: `_VAR3  $4AB =: `_WARY  $4A5 =: `_SETPNT        $41A =: `_SETVAR2      $41B =: `_SETVAR $4A0 =: `_POINT         $40B =: `_CONS2         $40A =: `_CONS3 $46F =: `_DEFER2        $46E =: `_DEFER3        $470 =: `_DEFER $461 =: `2DROPX         $4F4 =: `CF                                                                                             $41F =, NIP     ' `2DROPX  =, 2DROP;    $3EC =, ROT                                                                             <H                                                              HERE $E8 C, #DOES HERE  2+ - , >, C@ C, ;   DUP =, #CAL, $E8 ,    DUP =, #JMP, $E9 ,    DUP =, JMPS, $EB ,      =, RET, $C3 ,   : DOES, 0 : DOES- #DOES SWAP - : CALL, #CAL, : ,R HERE 2+ - , ; : CODE: HERE 2+ =, ;    : COMPILE @R+ , ;                       H> LIKE ! =, U<    $2B C, $DF C, #JMP, ' `CF ,R                 CODE: 0<  $D1 C, $E3 C, #JMP, ' `CF ,R           <H                                                                             : MRK>` HERE : Z, 0 , ;         : RLS>` HERE  SWAP! ;           : LATEST DICT CSTR + @ ;        : `;code POP : TOBE LATEST ! ;  : RECURCE` LATEST , ; { REFER TO SELF IN SAME OR NONAME WORD}   LIKE ;` =, DOES>` >, `;code DOES, ,<     { WE HAVE DOES !}      LIKE :  =, CONST ' `_CONS , ,' , { CONSTANTS}                   LIKE :  =, CREATE ' `_VAR ,  Z,       { RETURNS ONLY ADDRESS }  : (,) CREATE , DOES> @ , ; : BEGIN` HERE ; : >BEGIN` , ;        : (=) =H COMPILE ,< LIKE ;` , >, , , ; { commaers & DOERS}      HERE DOES, >, C@ HERE #DOES ROT - CALL, >, ;  DUP DUP            =, 0]> 0 C,  =, 1]> 1 C,  =, 2]> 2 C,                            0]> : `(TO C@ ' + ;  1]> RECURCE , ; 2]> RECURCE EXEC ;                =, TO     =, TO`     =, 'TO  2 C,                      ' TO STR =, AT STR =, AT`   @ =, 'AT  4 C,                                            ' { =: {`       { COMPILING VERSIONS}                                                                                                                                     H>                                                              : TIMES SWAP PUSH                    { LOOPS & TIMES FUNCTIONS} : LOOPS (FOR MRK> BEGIN J EXECUTE (NEXT >BEGIN RLS> RDROP ;     : (" (ASTR ;    { STRING LITERAL}                               : (."    (ASTR  { COMPILETIME STRING LITERAL EMITER }           : ".     CSTR   { RUNTIME STRING LITERAL EMITER FUNCTION}       : TYPE   ;DROP  : ?TYPE  LOOPS CSTR                             : ?EMIT  DUP bl U< (IF MRK> DROP '. RLS>  EMIT ;                : ;SPC  EX      : SPACE bl EMIT ;       : ID. ;SPC ". ;                                                                         : DXEP+ 1+ : DXEP DUP : XEP XCHG EXECUTE POP ;  LIKE J =, I 0 , : !- 2- DXEP ! ;        : @- 2- DXEP @ ;                        : C!- 1- DXEP           : C! C!+ DROP; ,<                                                                                                                                                                                                                       : ;2DROP EX 2DROP; ,<   : WITHIN OVER - PUSH - POP U< ;         : ;STK @+ @ WITHIN 0= ??                                        : ;@! @+ XCHG EXECUTE POP !- DROP; ,<   : U1- XEP 1- ;          : ;RANGE U1- OVER - EX DROP; ,< : TWICE I PUSH ;                : (CALL @R+ PUSH ;     : NUP XEP DUP ;  : ;GO @R+ XCHG PUSH ;   : TUCK  DUP : USWAP XEP SWAP ;          : -ROT ROT ROT ;        : BACK3 POP 6 - PUSH ;          : 0; 0?SKIP DROP; RDROP ;       : 2DUP OVER OVER ;                                              LIKE DUP =, U/MOD                                               $33 C, $C9 C, $91 C, $92 C, $F7 C, $F3 C, $93 C, $91 C, RET,    LIKE DUP =, SM*  $93 C, $F7 C, $EA C, $92 C, $93 C, RET,        LIKE DUP =, UM*    $93 C, $F7 C, $E2 C, $92 C, $93 C, RET,      : U* UM* DROP; ,<                                                                                                                                                                                                                                               { CONSTANTS   VARIABLES VALUES  & DEFERS}                        16 CONST 1H      '0 CONST '0'     3 CONST 3       1 CONST  1   256 CONST 1B     255 CONST &BYTE  26 CONST eof     2 CONST  2   $7C CONST NPAD  1024 CONST 1K     64 CONST 1L     -1 CONST -1   : W>B &BYTE AND ; : L>H 1B U* ; : BB>W  L>H SWAP W>B XOR ;      : W>BB 1B U/MOD ;       : B>HH W>B 1H U/MOD ;   : 2* DUP + ;                                                                                       : `NEG 2DUP XOR 0< 0; EX NEG ;               : /MOD `NEG ABS SWAP ABS SWAP  U/MOD ;                          : ITEMS @+ 2+ @ SWAP - : 2/ 2                                   : / /MOD NIP; ,<        : MOD /MOD DROP; ,<                                                                                                                                                                                                                                                                                                                                                     { searching }                                                   <H      : >IP+ NOT 3  AND 2* POP + PUSH ;                       { READ , COMPILE WORD & POSITION TO NEXT}                       : W, STR : A, 3 OPER[] @EXEC ;                                  : (:) CREATE DUP C, >IP+ , , , ,'       { THE MAKER !!!}                DOES> CSTR =H >IP+ W, W, W, @EXEC ;                                                                                     : (",)  '" : (?",)   WORD       { PARSE & COMPILE STR     }     : CSTR, CSTR                    { COUNTED STRING COMPILE  }     : STR, ;HERE (S! DROP; ,<       { ADR COUNT STRING COMPILE}     H>                                                                                                                              ' `_VAR                                                          1]> DUP STR 2- SWAP ;STK !- ;                                   2]> DUP @+ ;STK @+ ;                                                                                                             0]> C@ EMIT ;   1]> C@ ;                                      <H                        2 (:) CONST.C C,                      : STK, TUCK , , , ;       3 (:) STACK STK,                      ' `_DEFER    1 (:) DEFER ,                                      ' `_SETVAR   ' `_CONS2    2 (:) VALUE ,                         ' `_SETVAR   ' `_DEFER2   2 (:) VECTOR ,                        ' `_SETPNT   ' `_POINT    2 (:) POINT  ,                        ' `_VAR      ' `_SETVAR2  ' `_CONS3   3 (:) QUAN ,              ' `_VAR      ' `_SETVAR2  ' `_DEFER3  3 (:) VQUAN ,                                                                             0 VECTOR `vCREATE               : uOVER+ XEP : OVER+ OVER + ;   : FAMILY   ;2DROP ' TO `vCREATE LOOPS DUP uOVER+                        ;2DROP LTIB TOKEN? 1+ @ $2D2D XOR 0;                            RDROP TO LTIB `vCREATE ;                                H>                                                                                                                              10 CONST.C lf   13 CONST.C cr   8 CONST.C bs  '- CONST.C '-'                                                                    : ;[] '[ EMIT EX '] EMIT ;      : CR TO cr  TO lf  0 TO CNTC ;  : ALPHA  9 OVER U<  7 AND + '0' + ;                                                                                             : SHN3 CR  3 LOOPS ROT DUP              : H. W>BB (CALL MRK>    : B. ;SPC RLS> B>HH TWICE               : DIG.  ALPHA EMIT ;                                                                    : .   DUP 0< (IF MRK>  TO '-' ABS RLS>  : U.    ;SPC            : `U. lf U/MOD 0?SKIP RECURCE DIG. ;                                                                                                                                                                                                                                                                                                                                                                                                                            : OR OVER NOT AND XOR ;                                         : 2/ 2 : U/ U/MOD NIP; ,<       : ODD 1 AND ;                                   : = <> 0= ;                                     : <? 2DUP : < - 0< ;            : >SORT <? 0; SWAP ;            : MIN >SORT NIP; ,<             : MAX >SORT DROP; ,<                                                                            : UMOD U/MOD DROP; ,<                                           { : U* UM* DROP; ,<}                                            : +! ;@! + ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <H   TBL TIB +  TBUF  STACK CSTK        ' >BEGIN` =: <RELEASE   : CSWAP` CSTK CSTK SWAP TO CSTK  TO CSTK ; : CASE` 0 TO CSTK ;  : <RELEASE> <RELEASE : RELEASE> HERE CSTK ! ;                   : MARK> HERE TO CSTK  Z, ;     : >MARK< MARK>  : <MARK BEGIN` ; ' MARK>      '     (IF (=) IF`          ' RELEASE> =: THEN`     H>                                                              : (OF OVER <> @R+ SWAP IF XCHG SKIP THEN DROP DROP; ,<          <H                                                              ' RELEASE>   ' EXIT    (=) ;THEN`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ' >MARK<   ' (FOR (=) FOR`      ' <RELEASE> ' (NEXT (=) NEXT`   ' <MARK    ' PUSH (=) FOR>`     ' <RELEASE  ' (NEXT (=) <NEXT`  ' MARK>    ' (CALL (=) CALL`    ' <RELEASE  ' (JUMP (=) AGAIN`  ' <RELEASE ' (IF (=) UNTIL`     ' MARK>     ' (JUMP (=) AHEAD`  ' MARK>    ' (#IF (=) #IF`      ' MARK>     ' (OF   (=) OF`                                                                     : REPEAT` AGAIN`  THEN` ;          ' IF`   =: WHILE`            : ELSE`   AHEAD` CSWAP` THEN` ;    ' ELSE` =: ENDOF`                                                                            : ;CASE` COMPILE DROP BEGIN CSTK #IF TO CSTK THEN` REPEAT DROP   ;                                                              ' (",) ' ("   (=) "`    { STRING LITERALS  COMPILER      }      ' (",) ' (A"  (=) A"`   { STRING ERROR MESSAGES  COMPILER}      ' (",) ' (."  (=) ."`   { STRING LITERALS OUTPUT COMPILER}                                                                                                                                      H>  LIKE (DE =, (BE                                             $96 C, $31 C,  $DB C, $B4 C, $E C, $CD C, $10 C, $96 C, RET,                                                                    LIKE STR =, (BK                                                 $31 C,  $DB C,  $93 C,  $CD C,  $16 C,  $08 C,  $C0 C,  $74 C,  $02 C,  $30 C,  $E4 C,  $93 C,  RET,                                                                                            ' (BK VQUAN KEY                                                 : (AC   { ADR CNT / ADR CNT1 } OVER + PUSH DUP                    BEGIN  KEY     CASE                                                cr OF  DUP XCHG DROP  ENDOF                                     bs OF  2DUP <>  IF 1- TO bs SPACE  TO bs THEN  ENDOF            DUP bl 1B WITHIN  IF DUP EMIT SWAP C!+ DUP THEN                          ENDCASE    DUP I =                                  UNTIL RDROP OVER - 1 : SPACES LOOPS SPACE ;                                                                                   { : REGS _DX _CX _BX _AX ;}   : D0 0 0 ;  2 QUAN EOS            D0 9 FAMILY VALUE _AX _BX _CX _DX _FR BLK SCR XY SPTR           CODE: (IO                                                        $88 C,  $1E C,  HERE 12 + ,     $56 C,  $94 C,  $5B C,  $59 C,  $5F C,  $94 C,  $97 C,  $92 C,  $57 C,  $CD C,  $21 C,  $5F C,  $97 C,  $94 C,  $52 C,  $51 C,  $53 C,  $57 C,  $9C C,  $94 C,  #JMP, ' `2DROPX ,R     : IO? _FR ODD A" :IO?" ;                : CMOVE ;2DROP LOOPS PUSH CSTR POP C!+ ;                        : CMOVE> SWAP OVER + (MPUSH DROP ;                              : >S SPTR OVER PUSH (MPUSH XCHG POP C!- TO SPTR ;                0]> C@  : FILL  -ROT ;2DROP LOOPS NUP C!+ ;                    DUP =, ERASE 0 C,  =, BLANK bl C,                               : ONPLACE ;GO TO MRK>  DXEP  TWICE NUP  RLS>                    : REVERT   ;2DROP  BEGIN 1-  2DUP U< 0;                              PUSH PUSH  J C@  I C@  J C!    POP  C!+ POP  AGAIN ,<                                                                      0]> C@  (IO  TO _FR  TO _AX  TO _BX  TO _CX  TO _DX ;           DUP =, (DOS $21 C,  DUP =, (VID $10 C,   =, (KBD $16 C,         0]> @ (DOS ;    DUP =, `OPEN $3D02 ,   DUP =, FREAD  $3F00 ,    DUP =, FWRITE  $4000 , DUP =, FSEEK  $4200 , =, `CREATE $3C00 ,                                                                 0]> @ PUSH D0 ROT POP (DOS ;                                    DUP =, FSIZE  $4202 ,   DUP =, FPOS  $4201 ,  =, FCLOSE $3E00 ,                                                                 : =" '" WORD CSTR                                               : >ZSTR { A L - ZA } NPAD (S! SWAP : OFF 0 SWAP! ;              : ;File CSTR >ZSTR 1+ D0 EX IO? _AX ;                           : FOPEN ;File  `OPEN ;        : FCREATE ;File `CREATE ;                                                                                                                                                                                                                                                                         : [],  HERE DUP PUSH 2- DUP =: EXEC POP -                       : CLARY HERE OVER ERASE  : ALLOT ;HERE + ;                                                                                      $5C NPAD STACK HANDLES         : EOS? EOS ODD ; 0 QUAN `FBUF                                                                    : ;EOS AT EOS : ;@>!  DUP XCHG I @ PUSH PUSH ! EX POP POP ! ;   : FHTOP AT HANDLES @ @ ;  { SOMETHING }                         : FGET `FBUF CALL DROP  cr : EOS! EOS 1+ TO EOS ;THEN             AT `FBUF 1 FHTOP FREAD  _AX 0;  { IF EOF THEN EOS}              DROP `FBUF  DUP eof XOR 0; RDROP  ; { CONTROLS - LIKE BL }    : ;FILE TO HANDLES  AT KEY @ XCHG PUSH LIT FGET TO KEY               EX POP TO KEY      : `CLOSE1 HANDLES FCLOSE ;                                                                                                                                                                                                                                                                              : ;TI BLK XCHG LTIB PUSH ETIB PUSH PUSH                           CALL EX POP POP POP THEN  TO BLK TO LTIB TO ETIB              : /BLK  BLK 0; 0 TO ETIB ; : `// EOS 0; : // 0 TO LTIB ;        : INCLUDE TOKEN? : INCLUDED FOPEN ;FILE  `//                              D0  0 ;TI      2 ;EOS BEGIN vINIT EVAL EOS? UNTIL ;   : FTYPE TOKEN? FOPEN ;FILE 0 ;EOS BEGIN KEY EMIT EOS? UNTIL ;   : SEVAL CSTR 0 ;TI 0 ;EOS  ETIB LTIB EVAL ;                     : `CLOSE_ALL    AT HANDLES ITEMS  LOOPS `CLOSE1 ;               : (ERR  CR  TBUF ID.  STATE ".  CR  LIT (BK TO KEY  `CLOSE_ALL       BLK 0; BLK TO SCR 1K LTIB - : >XY 1K 1- AND  TO XY ;                                                                       : @OK ." Ok" CR ." >>" ;  META @OK vOK.                                                                                                                                                                                                                                                                                         { META @OK vOK. }                                               : `;HOME EX : HOME D0 : @XY BB>W D0 $200 (VID ;                 : PAGE `;HOME  0 24 @XY  25 : CRS  LOOPS CR ;                   { META (AC ACCEPT    META (BE  EMIT}                                                                                            { 0 VALUE DPTR  0 VALUE ADR  0 VALUE NPTR }                     : ?DU U/MOD SWAP 0; 1+ ;                                                                                                        =H (SCAN> >, POP RDROP POP SWAP - 1- NIP; ,<                    : SCAN     OVER PUSH PUSH  FOR  STR J XOR                                       (IF (SCAN> NEXT J (JUMP TO (SCAN> ,<            : BSCAN W>B OVER PUSH PUSH FOR CSTR J XOR                                       (IF (SCAN> NEXT J (JUMP TO (SCAN> ,<            : WD bs ?DU ;DROP LOOPS CR DUP H. bs LOOPS STR H. ;                                                                                                                                             <H : M: ';  : ?M: CREATE (?",) DOES> SEVAL ; { MACROSES } H>    <H M: -IF` DUP 0< IF; H>                                        LIKE ;` =, WARY LIKE OPER[] ,    ,' [],                         LIKE ;` =, BARY LIKE OPER[] 2+ , ,' [],                                                                                              4 CONST `NBUFS                                              $E000 CONST `FIRST                                                  0 VALUE SCRH                                                    0 VALUE `PREV                                                   0 VALUE `USE                                                                                                                                                                                                                                                                                                                                                                                                                                               : `RW 1K UM* SCRH FSEEK  IO?  1K SCRH  EX IO? ;                 : `WBLK `RW FWRITE ;    : `RBLK `RW FREAD ;                                                                                     `NBUFS BARY `FBUFS    `NBUFS WARY  `BUFS                                                                                        : `@BUF `PREV 1K U* `FIRST + ;                                  HERE DOES, >, C@ `PREV `FBUFS C! ;                              DUP   =, DISCARD  0 C,  =, UPDATE  -1 C,                        : -BUF DISCARD -1                                               : `!BUF `PREV `BUFS ! ;                                         : `+BUF `USE 1+ `NBUFS 1- AND DUP TO `USE ;                                                                                                                                                                                                                                                                                                                                                     : !BUFS  `NBUFS LOOPS `+BUF TO `PREV                            : `?SAVE `PREV `FBUFS C@ 0; `@BUF `PREV `BUFS @ `WBLK DISCARD ; : FLUSH !BUFS                                                   : /BUFS `NBUFS  LOOPS `+BUF TO `PREV                            : `EMPTY-BUF -BUF                                               : `/BUF `@BUF 1K ERASE ;                                        : `?BUF PUSH 0 `BUFS `NBUFS POP SCAN ;                          : `;ABLK /BLK 0 TO _FR XCHG PUSH EX RDROP `@BUF IO? ;           : BUFFER `;ABLK J `?BUF -IF `?BUF                                     -IF DROP `+BUF THEN THEN TO `PREV `?SAVE `/BUF J `!BUF ;  : BLOCK `;ABLK J `?BUF                                                         -IF DROP J BUFFER J `RBLK ;THEN TO `PREV ;                                                                                                                                                                                                                                                                       : (SRC BLK ETIB 0?SKIP NIP; DUP 0; BLOCK 1K + DUP TO ETIB ;     META (SRC SOURCE     $182 =: `DOEVAL                                                                                            : THRU ;RANGE LOOPS DXEP+                                       : LOAD DUP 0= A"  BLK0!" 0 1K ROT ;TI 0 ;EOS (JUMP `DOEVAL ,<   : `-USE SCRH 1+ 0; SCRH FCLOSE : `/SCR -1 TO SCRH ;             : USE/ `/SCR /BUFS ;                                            : USING FLUSH `-USE TOKEN? FOPEN TO SCRH ;                      { USING T123.GGG  ' @XY =: ATXY }                               USE/    USING T123.GGG                                          : +BLK BLK + ;  : L/ 1L NEG AND ;    { LINE BEGIN FUNCTION }    : ?EXIST; LOCATE 0= 0?SKIP DROP; RDROP                          : \ LTIB 1- L/ TO LTIB ;  ' \  =: \`    ' // =: //`               META (ERR vERR                  { SHOW ERROR ROUTINE }        ' , 3 OPER[] !                                                                                                                  0 VALUE ADR                                                     : HERE+! HERE : +! DUP PUSH @ + POP ! ;                         : 0;LIST 0 HERE !                                               : ;LIST DICT AHEAD BEGIN DUP CSTR + @+ PUSH J EXECUTE                   IF CSWAP> POP THEN  .C@ 0= UNTIL SKIP THEN POP RDROP ;  : ;CR EX CR ;                                                   : `ALI_13 cr CNTC : ALI_N OVER UMOD - SPACES ;                  : `;CNTC  OVER  C@  CNTC + 75 U<  1  HERE+!                       IF EX CNTC 65 U<    IF CSWAP>  `ALI_13 bs  ;THEN CR               EX `ALI_13 SKIP THEN ;CR  ADR 1- DUP TO ADR 0=                IF (BK  27 <>  bs TO ADR SKIP THEN bs ;                                                                                       : WORDS CR  ;DROP  bs TO ADR  0;LIST `;CNTC   H. ". ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ?EXIST; ;CR                                                     : ;CR EX CR ;    0 VALUE LCOUNT   : UMOD U/MOD DROP; ,<         : ;LIST DICT  AHEAD BEGIN  DUP CSTR + @+ PUSH  J EXECUTE                IF CSWAP POP THEN  .C@ 0= UNTIL SKIP THEN POP RDROP ;   : `LALI13 cr : LALI { SPACE} CNTC OVER UMOD - SPACES ;          : `;CNTC  OVER  C@  CNTC + 75 U<                                  IF EX CNTC 65 U<    IF CSWAP  `LALI13 bs  ;THEN CR                EX `LALI13 SKIP THEN ;CR  LCOUNT 1- DUP TO LCOUNT 0=          IF (BK  27 <>  bs TO LCOUNT SKIP THEN bs ;                                                                                    : WORDS CR  ;DROP  bs TO LCOUNT  ;LIST `;CNTC   H. ". ;                                                                                                                                                                                                                                                                                                                                         MARKER EDEL.    \ DELETE ENTRY IN DICTIONARY - DONT TOUCH CODE  57 LOAD \ ;LIST                                                 16 LOAD \ ONPLACE                                               : `VP CR J H. I H. SPACE  I @ ?ID.                                    SHN3 KEY 1- 0?SKIP DROP; ABORT ,<                         : -STR= OVER C@ 1+ FOR PUSH CSTR XCHG CSTR POP =  IF CSWAP            NEXT -1 SKIP THEN POP 1+ : 2NIP XEP 2DROP; ,<             : LOCATOR TO LCOUNT  ;LIST                                         DROP LCOUNT OVER  -STR= #IF DROP; THEN SWAP TO LCOUNT ;                                                                      : EDEL  TOKEN?  LOCATOR   LCOUNT TBUF =  0?SKIP 2DROP;                 PUSH DICT LCOUNT POP ONPLACE                             : DROPLAST DICT CSTR + STR DROP TO DICT ;                       \ D0 5 FAMILY VALUE  T5 T4 T3 T2 T1                                                                                                                                                             : WDUMP bs ?DU ;DROP LOOPS CR DUP H. SPACE bs LOOPS STR H. ;    : ;[] '[ EMIT EX '] EMIT ;                                      =H `;TYPE >, DUP 1H - 1H SPACE ;[] TYPE ;                       : DUMP 1H ?DU ;DROP : DU LOOPS CR DUP H. SPACE ;GO `;TYPE         1H LOOPS CSTR : B. ;SPC W>B 1H U/MOD  DIG. DIG. ;             0 VALUE `DPTR   0 VALUE `ADR  0  VALUE `NPTR                    : `END?  DUP TO `DPTR C@ ;  : `DNEXT `DPTR CSTR + @+ TO `NPTR ; : `SHN3 SPACE 3 LOOPS ROT DUP H. ;   0 VECTOR `?ID.             : SHN CR POP J H. PUSH J H. I H. `SHN3 I @ `?ID. KEY DROP ;     HERE DOES, >, CSTR `ADR SCAN 1+ 0; DUP ". NAME> CR ;            =, `?STR 3 C, >, (A"  (" (." ,<                                 : `-C>N `ADR 2- : C>N TO `ADR DICT SKIP BEGIN `NPTR `END?        WHILE `DNEXT `ADR = UNTIL THEN `DPTR C@ ;                                                                                      \ 60 LOAD                                                                                                                       : ?ID. CALL ID. : `ID. `DPTR ID. ;THEN                              C>N IF @R+ DROP ;THEN      `-C>N IF " TO" ;THEN               `-C>N IF " AT" ;THEN    RDROP  ." `$" `ADR 2+ 2+ H. ;         0 VALUE `WW : `;WW `WW EX TO `WW ;  ' ?ID. TO `?ID.             : `;?ID. EX C>N 0; `DPTR : [ID.] ;SPC ;[] ". ;                  : SEE ' : @SEE TO `WW : L bs LOOPS `;WW CR DUP H. `;?ID.           DXEP : `W1 STR DUP H. : `W2 DUP ?ID. TO `ADR `?STR ;         : WW CR DUP H. DUP PUSH `W1 POP C>N 0; `ID. ;                                                                                   : BE ' ! ; : WAS@ ' 2+ @ ; : HACK ' : @HACK TO `WW CR           : HL bs LOOPS `;WW `;?ID. DXEP STR `W2 ;                                                                                                                                                                                                                                                                                                                                                        \ BLOCKS.NVF                                                                                                                                                                                    \ MARKER EXT3.                                                                                                                  \ : `SIZE { HND -- DX:AX } `POSF IO? _DX _AX                    \    _BX `SIZE TO _CX _AX _DX  { DX:CX} ROT _CX _BX `SEEK ;     \ : Fcut { SCR -} `RW NIP D0 ROT FWRITE DROP ;                  \ : Fsize SCRH `SIZE 1K UM/MOD NIP ;                                                                                                 4 CONST `NBUFS                                              $E000 CONST `FIRST   \ 1 / 8 OT 64K                                 0 VALUE SCRH                                                    0 VALUE `PREV                                                   0 VALUE `USE                                                                                                               : `RW 1K UM* SCRH `SEEK  IO?  1K SCRH  EX IO? ;                 : `WBLK `RW FWRITE ;    : `RBLK `RW FREAD ;                                                                                     `NBUFS BARY `FBUFS    `NBUFS WARY  `BUFS                                                                                        : `@BUF `PREV 1K U* `FIRST + ;                                  HERE DOES, >, C@ `PREV `FBUFS C! ;                              DUP   =, DISCARD  0 C,  =, UPDATE  -1 C,                        : `!BUF `PREV `BUFS ! ;                                         : `+BUF `USE 1+ `NBUFS 1- AND DUP TO `USE ;                                                                                                                                                                                                                                                                                                                                                                                                                     : !BUFS  `NBUFS LOOPS `+BUF TO `PREV                            : `?SAVE `PREV `FBUFS C@ 0; `@BUF `PREV `BUFS @ `WBLK DISCARD ; : FLUSH !BUFS                                                   : /BUFS `NBUFS  LOOPS `+BUF TO `PREV                            : `EMPTY-BUF -1 `!BUF  DISCARD                                  : `/BUF `@BUF 1K ERASE ;                                        : `?BUF PUSH 0 `BUFS `NBUFS POP SCAN ;                          : `;ABLK 0 TO _FR XCHG PUSH EX RDROP `@BUF IO? ;                : BUFFER ;ABLK J `?BUF -IF `?BUF                                      -IF DROP `+BUF THEN THEN TO `PREV `?SAVE `/BUF J `!BUF ;  : BLOCK `;ABLK J `?BUF                                                         -IF DROP J BUFFER J `RBLK ;THEN TO `PREV ;                                                                                                                                                                                                                                                                       : `SOURCE BLK ETIB 0?SKIP NIP; DUP 0; BLOCK 1K + DUP TO ETIB ;  META `SOURCE SOURCE                                             : ;THRU PUSH 1- POP OVER - : ;DROP EX DROP; ,<                  : THRU ;THRU LOOPS 1+ DXEP                                      : LOAD DUP 0= A"  BLK0!" 0 1K ROT ;TIBLK (JUMP `DOEVAL ,<                                                                       : -USE SCRH 1+ 0; SCRH FCLOSE -1 TO SCRH ;                      : USING FLUSH -USE TOKEN? FOPEN TO SCRH ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       \ USING T123.GGG                                                : / U/MOD NIP ;                                                 ' @XY =: ATXY                                                   : BLANK bl FILL ;                                               : UMOD U/MOD DROP; ,<                                           : `AlignLeft { SPACE} cr CNTC OVER UMOD - SPACES ;              : !EMIT '! EMIT ;     0 VALUE G                                 : TESTS LOOPS CR G                                              : TEST SPACES !EMIT   `AlignLeft  !EMIT    G . G 1+ TO G ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                      \ NUMOUT                                                                                                                        ?EXIST;  HLD                                                                                                                    0 VALUE  `BASE  0 VALUE HLD     : ;HLD HLD EX TO HLD ;          : BASE! 2 MAX TO `BASE  ;  : <# 0 TO HLD ;                      : `SGN# <# 0; NEG EX '- : HOLD ;HLD  C!- ;                      : 1# `BASE U/MOD SWAP   : AHOLD ALPHA  HOLD ;                   : `N#  XEP DUP 0<  `SGN#  : S# 1# 0?SKIP BACK3 ;                : .R lf : .RB BASE!  `N# HLD + SPACES                           : #> HLD DUP NEG TYPE ;                                                                                                                                                                                                                                                                                                                                                                         \ LIST                                                          ?EXIST;  LIST                                                                                                                   : LIST DUP TO SCR BLOCK                                         : .BLOCK  ;DROP ." SCR# " SCR . CR 1H LOOPS CR 1H  J -          : .LINE 4 .R SPACE 1L ;[] ?TYPE ;                               : INDEX ;RANGE LOOPS DXEP+ BLOCK CR J ;DROP .LINE ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             { STRINGS   }                                                   ?EXIST;  ST                                                                                                                     : ST  SPTR CSTR ;                      {  \ STACK TOP / NEXT  } : S> SPTR            : SDROP  ST + TO SPTR ; {  \ DROP STRING }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 \ SWITCH                                                        ?EXIST;  XK                                                     0 VALUE XK      : WHAT? 7 EMIT ;                                 0]> SWAP TO XK CSTR 2DUP XK BSCAN 1+ 2* + + @EXEC ; =: XK!                                                                     <H                                                              : -:  ' , C,  XK 2+ DUP TO XK       { BYTES FOR MOVE UP 1 }              HERE OVER - DUP PUSH       { START ADDRESS    }                 DUP 1+ ROT                 { PREPARE FOR MOVE }                 CMOVE>  HERE C@ POP C!   ; { FIX CODE  }               : SWITCH: CREATE HERE 73 1 TO XK 0 -: LIT  XK!  TOBE ;          : ;SWITCH  73 - A" BAD KEYS" XK 2/ 1- SWAP C! ;                 H>                                                                                                                                                                                                                                                              { EDITOR.NVF  }                                                                                                                  66     69 THRU                                                                                                                 D0 3  FAMILY VALUE `PDATA `INS `SPTRFIX                         0 POINT `ASTEP                                                  ' -BUF =: `EJECTBLOCK                                                                                                            71     75 THRU                                                                                                                 <H 55 LOAD 5  LOAD  FORGET kHOME  H>                                                                                            { 4 LOAD}                                                                                                                                                                                                                                                       : `?XY 1L U/MOD 6 3 ROT + XEP + ;                               : `POSXY XY `?XY @XY   ;                                        : `_INS  `INS 0= TO `INS                                        : `.INS  75 1 @XY `INS IF ." INS" ;THEN ." OVT" ;               : `;LRUD  XY EX >XY ;                                           : `;LPOS  XY EX `PDATA + ;                                      : `RELOAD SCR BLOCK TO `PDATA `SPTRFIX  DICT <> 0;                   DICT DUP TO `SPTRFIX TO SPTR  TWICE  D0  >S ;              : `REDRAW `.INS HOME CR  `PDATA .BLOCK ;                        : `L_UP  `;LRUD  1L - ;      { LINE UP  }                       : `L_DN  `;LRUD  1L + ;      { LINE DOWN}                       : `L_END `;LRUD              { DO LINE END}                     : `/L  1L 1- OR ;        { LINE END FUNCTION }                                                                                                                                                                                                                  { COPY POS^ LINE/ /LINE LDRAW EL INSC DELC OVTC INSL DELL LL}   : `<_|   `L_DN               { CARRIGE RETURN L_DN L_BEG }      : `L_BEG `;LRUD  L/ ;       { DO LINE BEGIN}                    : `>ADV  TO `ASTEP : `->    `;LRUD  1+ ;  { MOVE 1 CHAR RIGHT}  : `>BACK TO `ASTEP : `<-    `;LRUD  1- ;  { MOVE 1 CHAR LEFT}   : `TAB>  `;LRUD  7 OR 1+ ;   { NEXT TABULATION }                : `<TAB  `;LRUD  1- -8 AND ; { PREVIOUS TABULATION}             : `APOS  `;LRUD  0 AND ;     { HOME POSITION OF CURSOR   }      : `LINE/ `;LPOS  L/ ;  : `/LINE `;LPOS `/L ;                    : `LDRAW `POSXY `LINE/ XY 1L / 1+ cr EMIT .LINE DROP ;          : `RESET `EJECTBLOCK : `LOADRAW `RELOAD `REDRAW ; { !!!!!!! }   : `LB SCR + 0 MAX TO SCR `LOADRAW ;  { +blk - }                 : `LEOS 1K  XY - 1L - 0 MAX ; { - chars_to_end_of_screen }      : `POS^ `PDATA XY + ;          { - char^ }                                                                                                                                                      : `P2 `POS^ DUP DUP 1L + ;     { - char^ char^ char^+1l }       : `LL XY `/L XY - ;            { - chars_to_end_of_line }       : `1STEP XY 0= `ASTEP `POS^ C@ 33 U< ;                          : `N  1 `LB ;                                                   : `>NEXT  BEGIN `1STEP OR UNTIL BEGIN `1STEP 0= OR UNTIL ;      : `B -1 `LB ;                                                   : `ADV   `>ADV `>NEXT ;                                         : `>EL 1K `LEOS - 1L MIN ;                                      : `BACK  `>BACK `>NEXT `-> ;                                    : `EL `>EL BLANK ;  { ( ERASE LINE OR LESS)  }                  : `DELL `P2 SWAP `LEOS CMOVE `LEOS +  `EL                       : `RDRC `REDRAW UPDATE ;                                        : `>INSL `P2 `LEOS CMOVE> `EL ;                                                                                                                                                                                                                                 : `C `POS^ `>EL `L_DN >S ;                                      : `G `C `L_UP `DELL ;                                           : `P ST NIP 0;  `>INSL  SPTR CSTR SDROP                                 `>EL MIN `POS^ SWAP CMOVE `RDRC ;                       : `INSL `>INSL `RDRC ;                                          : `POSC `POS^ DUP 1+ ;                                          : `INSC `INS IF `POSC `LL CMOVE> THEN                           : `OVTC `POS^ C! UPDATE ;                                       : `BS `<- : `DELC `POSC SWAP `LL CMOVE bl                                     `/LINE C! `LDRAW UPDATE ;                         : `ESQ/E { EMPTY-BUFS} /BUFS                                    : `X-POS 71 18 @XY   EOS! ;                                     : `Q/ED  FLUSH  `X-POS ;                                                                                                                                                                                                                                        <H      76 LOAD H>      \ EDIT E HELP                           SWITCH: `EF WHAT?                  kLEFT -: `<-    kUP -: `L_UP  kHOME -: `L_BEG   kEND -: `L_END  kPGUP -: `B   kPGDN -: `N     kDOWN -: `L_DN  kRIGHT -: `->     kINS  -: `_INS kDEL -: `DELC  ksTAB -: `<TAB  kcHOME -: `APOS        ;SWITCH                 : `ONEC XK bl U<  IF WHAT? ;THEN XK `INSC `LDRAW `-> ;          SWITCH:  `EK  `ONEC   ^J -: `<-  ^K -: `->     ^X -:  `G          127 -: `DELL    bs -: `BS        ^D -: `DELC  cr -: `<_|       ^N -: `N     ^B -: `B    ^L -: `RESET   ^I -: `TAB>             ^C -: `C     ^V -: `P    ^Q -: `ESQ/E   ^Z -: `BACK             ^A -: `ADV   kESQ -: `Q/ED  ^S -: `INSL   0 -: `EF  ;SWITCH    : `@KEY `POSXY (BK W>BB #IF SWAP ;THEN DROP ;                   : HELP ;GO MRK> SCR XEP : `(E RLS> TO SCR : E `LOADRAW          0 ;EOS BEGIN `@KEY `EK EOS? UNTIL ;   : EDIT PAGE `(E ;                                                                                                                                         \ KEY CONSTANTS                                                                                                                 1  71  7 FAMILY CONST  kHOME  kUP  kPGUP  -- kLEFT  -- kRIGHT   1  78  7 FAMILY CONST  -- kEND  kDOWN  kPGDN  kINS  kDEL  ksF1  1 113  7 FAMILY CONST  kaF10 -- kcLEFT kcRIGHT kcEND -- kcHOME  1 59  10 FAMILY CONST  kF1 kF2 kF3 kF4 kF5 kF6 kF7 kF8 kF9 kF10   9  CONST kTAB       104  CONST kaF1       93  CONST ksF10      94  CONST kCF1       103  CONST kcF10      15  CONST ksTAB      1 1  12 FAMILY CONST  ^A ^B ^C ^D --E --F --G --H ^I ^J ^K ^L   1 13 11 FAMILY CONST  --M ^N --O --P ^Q --R ^S --T --U ^V --W   1 24  4 FAMILY CONST  ^X --Y ^Z kESQ                                                                                                                                                                                                                                                                                                                                                           \ DEBUG NVF     MARKER DEBUG.                                                                                                   HERE DOES, >, CSTR ADR SCAN 1+ 0; DUP ". CSTR + ;               =, ?STR 3 C, ' A"` 2+ @ ,  ' "` 2+ @ ,  ' ."` 2+ @ ,            \ WDUMP bs ?DU ;DROP LOOPS CR DUP H. bs LOOPS STR H. ;                                                                          : <ID? ADR 2- : #>ID? TO ADR DICT SKIP                           BEGIN NPTR END? WHILE DNEXT ADR = UNTIL THEN DPTR C@ ;         : ?ID. CALL ID. DPTR ID. SPACE ;THEN                                 #>ID? IF @R+ DROP; THEN                                          <ID? IF " TO" ;THEN                                             <ID? IF " AT" ;THEN                                             RDROP ." `$" ADR 2+ 2+ H. ;                                                                                                                                                                                                                               : ;[] '[ EMIT EX '] EMIT ;                                      : ;?ID. EX #>ID? 0; ;SPC ;[] DPTR ". ;                                                                                          0 VALUE `WW     : `;WW `WW EX TO `WW ;                                                                                          : SEE ' : @SEE TO `WW   : L bs LOOPS `;WW                        CR DUP H. ;?ID. DXEP STR DUP H. : `W2 DUP ?ID. TO ADR ?STR ;                                                                   : HACK ' : @HACK TO `WW CR                                      : HL bs LOOPS `;WW ;?ID. DXEP STR `W2 ;                                                                                         LIKE `;HOME 1+ =, `TYPE >, DUP 1H - 1H SPACE ;[] ;DROP ?TYPE ;  : DUMP 1H ?DU ;DROP                                             : DU LOOPS CR DUP H. SPACE `TYPE   1H LOOPS CSTR                : B. ;SPC W>B `B. ;                                                                                                             \ ACCEPT                                                        \ (AC   { ADR CNT / ADR CNT1 } PUSH 0                           \ BEGIN  KEY     CASE   cr OF  RDROP EXIT ENDOF                 \    bs OF  #IF 1- TO bs SPACE  TO bs THEN  ENDOF               \    DUP bl 1B WITHIN                                           \    IF PUSH 2DUP + I SWAP! POP EMIT 1+ DUP THEN                \             ENDCASE    DUP I =                                \ UNTIL RDROP ;                                                 : (AC   { ADR CNT / ADR CNT1 } PUSH XCHG 0                        BEGIN  KEY     CASE   cr OF  NIP DUP ENDOF                         bs OF  #IF 1- R1- bs EMIT SPACE bs EMIT THEN  ENDOF             DUP bl 1B WITHIN  IF DUP EMIT !R+ R1- DUP THEN                           ENDCASE    2DUP  =                                  UNTIL POP - SWAP ;                                                                                                                                                                            \ NF7.NVF                                                                                                                       $13A =: HERE    $3E2 =: !       $235 =: ;`      $10C =: EMIT    $22F =: :       $27D =: =,      $215 =: C@      $273 =: ;HERE   $424 =: C!+   : C, ;HERE C!+ ;  $209 =: +       $207 =: -       HERE  $4B C,   HERE  $4B C,  $EB C,  $4F4 2 +  HERE 1 + - C,      =, 1-  =, 2-                                                                                                                  $259 =: ,       $1AC =: DROP;   $1EA =: DUP     $1FD =: ,<`     $48B =: >,                                                      $29D =: WORD    $48D =: #DOES   $1F8 =: @                       HERE $E8 C, #DOES HERE 2 + - ,  >, C@ WORD DROP; ,<             DUP =, \ 0 C,  =, { '} C,                                                                                                       $2BB =: #??     $3FE =, AND     $299 =: TOKEN?  $221 =: FIND                                                                    : LOCATE TOKEN? FIND 1 AND ;  : ' LOCATE #?? ;   : LIKE ' @ ;   : ,' ' , ;                                                                                                                      $130 =: bl              \ RETURNS ASCII CODE OF SPACE CHARACTER $24B =: SKIP    $1A8 =: ;DROP   $245 =: (NEXT   $4B1 =: (FOR    $247 =: RDROP                                                   $444 =: PUSH    $47F =: EXECUTE $241 =: J       $20B =: STR     $1DD =: (ASTR   \ _ASTR - STRING PRIMITIVE                      $219 =: CSTR    \ _CSTR - CSTRING > COUNT ADDRESS               $194 =: (A"     \ TYPES WORD  TYPES "ERROR KIND" & ABORTS       $1FF =:  3+        \ _3P                                                                                                                                                                                                                                                                                                                                                                        $152 =: CNTC    \ COUNT OF EMITTED CHARS ON OUTPUT STREEM       $118 =: vOK.    \ VECTORED RESPONCE OF THE SYSTEM IF NO ERROR   $1C2 =:  ;DPUSH    \ _XDPUSH                                    $11C =: vERR       \ _ERROR  - DEFER ERROR                      $128 =: TBUF       \ _TBUF                                      $24D =: ABORT      \ _ABORT                                     $158 =: STATE      \ _STAT                                      $14C =: DICT       \ _DICT                                      $253 =: POP        \ _POP                                       $27F =: =H         \ _ENTRYH                                    $487 =: @EXEC      \ _PERFORM                                   $12C =:  0         \ _0                                         $2BD =:  ??        \ _??                                        $39D =: (DE        \ _@EMIT                                                                                                                                                                     $1AE =:  @_INI     \ _@_INI                                     $4E6 =:  ABS       \ _ABS                                       $38B =: (ACC       \ _ACC                                       $114 =:  ACCEPT    \ _ACCEPT                                    $23B =:  #,`       \ _CLIT                                      $2D0 =: (,EX       \ _COMMAER                                   $261 =:  NUM,      \ _COMP_NUM                                  $212 =:  .C@       \ _DLDB                                      $1C4 =: >DICT      \ _DPUSH                                     $203 =:  DROP      \ _DROP                                      $4C2 =:    (#IF    \ _DUP_IF                                    $140 =:  ETIB      \ _ETIB                                      $178 =:  EVAL      \ _EVAL                                      $251 =:  EX        \ _EX                                                                                                                                                                        $483 =:  EXEC      \ _EXEC                                      $24F =:  EXIT      \ _EXIT                                      $3A9 =: (FND       \ _FND                                       $4C8 =: (IF        \ _IF                                        $134 =: vINIT      \ _INIT                                      $249 =: (JUMP      \ _JUMP                                      $1F2 =:  LIT       \ _LIT                                       $146 =:  LTIB      \ _LTIB                                      $36D =: (MPUSH     \ _MPUSH                                     $37A =: (S!        \ _MSTR                                      $255 =:  NIP;      \ _NIPX                                      $362 =: (NUM       \ _NUM                                       $269 =:  NUMBER    \ _NUMBER                                    $102 =:  OPER[]    \ _OPERATION                                                                                                                                                                 $205 =:  OVER      \ _OVER                                      $33E =: (PARS      \ _PARS                                      $29F =:  PARSE     \ _PARSE                                     $1D7 =: @R+        \ _RLDP                                      $110 =:  SOURCE    \ _SOURCE                                    $42A =:  !+        \ _STP                                       $201 =:  SWAP      \ _SWAP                                      $120 =:  TBL       \ _TBL                                       $124 =:  TIB       \ _TIB                                       $29B =:  TOKEN     \ _TOKEN                                     $1E5 =:  XCHG      \ _XCHG                                      $257 =:  ;COMMA    \ _XCOMMA                                    $2B1 =:  ;SETSTR   \ _XSETSTR                                   $2B9 =:  ;TOK?     \ _XTOK?                                                                                                                                                                     $4EF =:  0=        \ _ZEQ                                       $4B8 =:  0?SKIP    \ _ZSKIP                                                                                                     \ ----------------------------                                                                                                  $4EB =: `NOT                                                    $4E3 =: `1P                                                     $42F =: `1P_NIP                                                 $462 =: `2DROP                                                  $461 =: `2DROPX                                                 $4E2 =: `2P                                                     $42E =: `2P_NIP                                                 $4E1 =: `3P                                                     $165 =: `ABORT                                                                                                                                                                                  $1AA =: `ABORTX                                                 $3FA =: `ADD                                                    $411 =: `ADR                                                    $4F4 =: `CF                                                     $491 =: `DOES                                                   $490 =: `DOES2                                                  $48F =: `DOES3                                                  $182 =: `DOEVAL                                                 $3A2 =: `DOS_DX                                                 $41D =: `DROP                                                   $416 =: `DROPX                                                  $496 =: `EX                                                     $472 =: `EXEC                                                   $4CA =: `IF                                                                                                                                                                                     $4CF =: `JUMP                                                   $4CC =: `JUMPDR                                                 $498 =: `LBL                                                    $21C =: `LDB                                                    $49A =: `MAIN                                                   $16E =: `MAINLP                                                 $4EA =: `NEG                                                    $497 =: `NEST                                                   $47D =: `NEST2                                                  $47C =: `NEST3                                                  $47B =: `NEST4                                                  $47A =: `NEST5                                                  $4D3 =: `NEXT                                                   $41F =: `NIP                                                                                                                                                                                    $431 =: `NIPX                                                   $2E6 =: `NUM                                                    $3F1 =: `OVER                                                   $3F2 =: `POP                                                    $441 =: `PUSHW                                                  $440 =: `PUSHW2                                                 $43F =: `PUSHW3                                                 $386 =: `PUSH_DC                                                $3AE =: `PUSH_SC                                                $4DE =: `RDROP                                                  $499 =: `RETURN                                                 $3EC =: `ROT                                                    $1CF =: `SETDROP                                                $4BF =: `SKIP                                                                                                                                                                                   $4BC =: `SKIPDR                                                 $3F8 =: `SUB                                                    $4DB =: `SWAP                                                   $4DA =: `SWAPX                                                  $1D1 =: `TOPDROP                                                $1EC =: `TOPDUP                                                 $401 =: `XOR                                                    $3E7 =: `_1M                                                    $3E6 =: `_2M                                                    $4AD =: `_BARY                                                  $44B =: `_CALL                                                  $2DA =: `_COMMA                                                 $40C =: `_CONS                                                  $40B =: `_CONS2                                                                                                                                                                                 $40A =: `_CONS3                                                 $470 =: `_DEFER                                                 $46F =: `_DEFER2                                                $46E =: `_DEFER3                                                $468 =: `_DEFERO                                                $1CE =: `_DROP                                                  $448 =: `_DUP                                                   $405 =: `_IJ                                                    $4A9 =: `_LARY                                                  $2DF =: `_MAKER                                                 $450 =: `_PARAM1                                                $453 =: `_PARAM2                                                $456 =: `_PARAM3                                                $4A0 =: `_POINT                                                                                                                                                                                 $434 =: `_RLD@                                                  $439 =: `_RST@                                                  $4A5 =: `_SETPNT                                                $41B =: `_SETVAR                                                $41A =: `_SETVAR2                                               $419 =: `_SETVAR3                                               $2C9 =: `_STATE                                                 $3E8 =: `_TOP?                                                  $3F5 =: `_VAR2                                                  $3F4 =: `_VAR3                                                  $4AB =: `_WARY                                                  $40E =: `_VAR                                                                                                                   \ -------------------------------------------------------------                                                                                                                                 \ HERE : CR 13 EMIT 10 EMIT ;     $11A !                        \ HERE : ERR '? EMIT '? EMIT '? EMIT ;     $11E !                                                                               LIKE ;` =, :` ,' SKIP ,' :                                      \ ":" - NOW DEFINES WORDS ON COMPILE STATE                      ' `2P  =, 2+            ' `1P  =, 1+  \ : C,R HERE 1+ - C, ;    HERE $E8 C, #DOES HERE    2+ - , >, C@ C, ;                     DUP =, #CAL, $E8 ,    DUP =, #JMP, $E9 ,                        DUP =, JMPS, $EB ,  =, RET, $C3 ,                               : DOES, #DOES           : CALL, #CAL,   : ,R HERE    2+ - , ;                                                                   LIKE ! =, U<                                                    $2B C, $DF C, #JMP, ' `CF ,R                                                                                                                                                                                                                                    : CODE: HERE 2+ =, ;                                            CODE: 0<  $D1 C, $E3 C, #JMP, ' `CF ,R                                                                                          LIKE DUP =, U/MOD                                               $33 C, $C9 C, $91 C, $92 C, $F7 C, $F3 C, $93 C, $91 C, RET,                                                                    LIKE DUP =, SM*                                                 $93 C, $F7 C, $EA C, $92 C, $93 C, RET,                                                                                         LIKE DUP =, UM*                                                 $93 C, $F7 C, $E2 C, $92 C, $93 C, RET,                                                                                         : U* UM* DROP; ,<                                                                                                                                                                                                                                               : * SM* DROP; ,<                                                                                                                ' `NEG =, NEG   ' `XOR =, XOR     ' `NOT =, NOT                 : COMPILE @R+ , ;                                               LIKE :  =, CONST ' `_CONS , ,' , \ CONSTANTS                    LIKE :  =, CREATE ' `_VAR ,  0 , \ ONLY ADDRESS NOTHING MORE    : (=) =H COMPILE ,< LIKE ;` , >, , , ;  \ DOERS                                                                                 : META '                                                        : IS '    2+ ! ;                                                : TIMES SWAP PUSH                                               : LOOPS (FOR  ,< HERE 10 + , >, J EXECUTE                               (NEXT ,< HERE 6 - , >, RDROP ;                          \ LOOPS & TIMES FUNCTIONS                                                                                                                                                                       LIKE @ =, ?BL.                                                  $80 C, $FB C, bl C, $73 C, 2 C, $B3 C, $2E C, RET,              ' `NEST3                                                        DUP  =, (."     \ COMPILETIME STRING LITERAL EMITER             DUP  =, ".      \ RUNTIME STRING LITERAL EMITER FUNCTION        =, TYPE  >, (ASTR CSTR ;DROP                                    : ?TYPE LOOPS CSTR                                              : ?EMIT ?BL. EMIT ;                                             : (" (ASTR ;    \ STRING LITERAL                                                                                                : ALLOT ;HERE + ;                                               : W, STR , ;    \ READ , COMPILE WORD & POSITION TO NEXT        ' \ =: \`       \ COMPILING VERSION                                                                                                                                                                                                                             ' { =: {`       \ COMPILING VERSION                                                                                             : LATEST DICT CSTR + @ ;        : ;code POP : TOBE LATEST ! ;   : RECURCE` LATEST , ;   \ REFERENCE TO SELF IN SAME WORD        LIKE ;` =, DOES>` >, ;code DOES, ,<     \ WE HAVE DOES !                                                                        \ CONSTANTS   VARIABLES VALUES  & DEFERS                         16 CONST 1H      '0 CONST '0'     3 CONST 3       1 CONST  1   256 CONST 1B     255 CONST &BYTE  26 CONST eof     2 CONST  2   $5C CONST NPAD  1024 CONST 1K     64 CONST 1L     -1 CONST -1                                                                   : 2* DUP + ;                                                    ' `NIP =, NIP                                                   : B>W &BYTE AND ;                                                                                                                                                                               : >IP+ NOT 3  AND 2* POP + PUSH ;                               : (,) CREATE , DOES> @ , ;      \ commaers  & --V MAKERS        : (:) CREATE DUP C, >IP+ , , , ,'                                      DOES> CSTR =H >IP+ W, W, W, @EXEC ;                                                                                      ' `_DEFER    1 (:) DEFER ,                                      ' `_SETVAR   ' `_CONS2    2 (:) VALUE ,                         ' `_SETVAR   ' `_DEFER2   2 (:) VECTOR ,                        ' `_SETPNT   ' `_POINT    2 (:) POINT  ,                        ' `_VAR      ' `_SETVAR2  ' `_CONS3   3 (:) QUAN ,              ' `_VAR      ' `_SETVAR2  ' `_DEFER3  3 (:) VQUAN ,                                                                             HERE DOES, >, C@ EMIT ;   HERE #DOES 1- CALL, >, C@ ;           2 (:) CONST.C C,                                                                                                                                                                                10 CONST.C lf   13 CONST.C cr   8 CONST.C bs  '- CONST.C '-'                                                                    \ searching                                                     HERE DOES, >, : `(' C@ ' + ;                                     DUP =, 'TO  2 C, =, 'AT  4 C,  \ ADDRESS OF XT+2 / XT+4        HERE DOES, >, `(' EXEC ; DUP =, TO   2 C,  =, AT  4 C,          \ EXECUTES XT+2 / XT+4                                          HERE DOES, >, `(' , ;    DUP =, TO`  2 C,  =, AT` 4 C,          \ COMPILES                                                                                                                      LIKE ;DPUSH =, ;SPC                                             \  EMIT SPACE IN THE END OF WORD  __RVAR2 _XSPC                 : SPACE bl EMIT ;       \ EMIT BLANK SPACE                      : ID. ;SPC ". ;                                                                                                                                                                                 : CR TO cr  TO lf  0 TO CNTC ;                                  \ : CR (." ,< 2 C, 13 C, 10 C, >, 0 ,< ' CNTC    2+ , >, ;      \ META  CR vOK.                                                                                                                 \  : (ERR  CR  TBUF ID.  STATE ".  CR ;                         \  META (ERR vERR                  \ SHOW ERROR ROUTINE                                                                         \ CONTINUE EXTENDING COMPILER                                   : 1+DXEP 1+ : DXEP DUP : XEP XCHG EXECUTE POP ;                 : (CALL @R+ PUSH ;                                              -#20 CONST FTOP   FTOP VALUE  FSTACK                            : ;FSTACK FSTACK EX TO FSTACK ;                                 ' , =: <RELEASE                                                                                                                                                                                                                                                 : F> FSTACK FTOP XOR #?? ;FSTACK : @+ STR SWAP ;                : >F ;FSTACK : !- 2- DXEP ! ;                                   : <RELEASE> <RELEASE : RELEASE> HERE F> ! ;                     : MARK> HERE >F : Z, 0 , ;      : >MARK< MARK>  : <MARK HERE ;  : CASE`  0 >F ;         ' XOR =: <>     : = <> 0= ;                                                                             ' MARK>    '    (IF (=) IF`               ' RELEASE> =: THEN`   : (OF OVER <> @R+ SWAP IF XCHG SKIP THEN DROP DROP; ,<          ' RELEASE> ' EXIT   (=) ;THEN`  '              <MARK =: BEGIN`  ' >MARK<   '   (FOR (=) FOR`    ' <RELEASE> ' (NEXT (=) NEXT`   ' <MARK    '   PUSH (=) FOR>`   ' <RELEASE  ' (NEXT (=) <NEXT`  ' MARK>    '  (CALL (=) CALL`   ' <RELEASE  ' (JUMP (=) AGAIN`  ' <RELEASE '    (IF (=) UNTIL`  ' MARK>     ' (JUMP (=) AHEAD`  ' MARK>    '   (#IF (=) #IF`    ' MARK>     ' (OF   (=) OF`                                                                                                                                     : CSWAP` F> F> SWAP >F >F ;                                     : REPEAT` AGAIN`  THEN` ;          ' IF`   =: WHILE`            : ELSE`   AHEAD` CSWAP` THEN` ;    ' ELSE` =: ENDOF`            : ENDCASE`  COMPILE DROP  BEGIN F> #IF >F THEN` REPEAT DROP ;                                                                   \ STRING COMPILING                                              : (",)  '" : (?",)   WORD       \ PARSE & COMPILE STR           : CSTR, CSTR                    \ COUNTED STRING COMPILE        : STR, ;HERE (S! DROP; ,<       \ ADR COUNT STRING COMPILE                                                                      ' (",) ' ("   (=) "`    \ STRING LITERALS  COMPILER             ' (",) ' (A"  (=) A"`   \ STRING ERROR MESSAGES  COMPILER       ' (",) ' (."  (=) ."`   \ STRING LITERALS OUTPUT COMPILER       : @OK ."  Ok" CR ." > " ;                                       LIKE J  =, I 0 ,        : TWICE I PUSH ;    \ META  @OK vOK.                                                                    \ ------------------------------------------------------------- \ NUMOUT                                                        \                                                               : U* UM* DROP; ,<       : W>B &BYTE AND ;       : L>H 1B U* ;   : BB>W  W>B L>H SWAP W>B XOR ;  : W>BB 1B U/MOD ;               : B>HH 1H U/MOD ;                                               : ALPHA  9 OVER U<  7 AND + '0' + ;           \  7 ALPHA EMIT   : H.  ;SPC  W>BB TWICE  : `B. B>HH TWICE  : DIG.  ALPHA EMIT ;  : .   DUP 0< IF TO '-' ABS THEN       : U.    ;SPC              : `U. lf U/MOD 0?SKIP RECURCE DIG. ;                                                                                                                                                                                                                                                                                                                                                                                                                            \ ------------------------------------------------------------- : 2DUP OVER OVER ;                                              ' `ROT =, ROT                                                   : WITHIN OVER - PUSH - POP U< ;                                 0 VQUAN KEY                                                                                                                     : (AC   { ADR CNT / ADR CNT1 } OVER + PUSH DUP                    BEGIN  KEY     CASE                                                cr OF  DUP XCHG DROP  ENDOF                                     bs OF  2DUP <>  IF 1- TO bs SPACE  TO bs THEN  ENDOF            DUP bl 1B WITHIN  IF DUP EMIT SWAP C!+ DUP THEN                          ENDCASE    DUP I =                                  UNTIL RDROP OVER - 1 : SPACES LOOPS SPACE ;                   LIKE (DE =, (BE                                                 $96 C, $31 C,  $DB C, $B4 C, $E C, $CD C, $10 C, $96 C, RET,                                                                    LIKE STR =, (BK                                                 $31 C,  $DB C,  $93 C,  $CD C,  $16 C,  $08 C,  $C0 C,  $74 C,  $02 C,  $30 C,  $E4 C,  $93 C,  RET,                                                                                            ' (BK TO KEY                                                    0 VALUE _AX     0 VALUE _BX     0 VALUE _CX                     0 VALUE _DX     0 VALUE _FR                                                                                                     CODE: (IO                                                        $88 C,  $1E C,  HERE 12 + ,     $56 C,  $94 C,  $5B C,  $59 C,  $5F C,  $94 C,  $97 C,  $92 C,  $57 C,  $CD C,  $21 C,  $5F C,  $97 C,  $94 C,  $52 C,  $51 C,  $53 C,  $57 C,  $9C C,  $94 C,  #JMP, ' `2DROPX ,R                                                                                                                                                                                                                                             \ : REGS _DX _CX _BX _AX ;                                      : ODD 1 AND ;                                                   0 VALUE BLK  0 VALUE SCR  0 VALUE XY  0 VALUE EOS?              : IO? _FR ODD A" :IO?" ;  : D0 0 0 ;                            HERE DOES, >, C@  (IO  TO _FR  TO _AX  TO _BX  TO _CX  TO _DX ; DUP =, (DOS $21 C,  DUP =, (VID $10 C,   =, (KBD $16 C,         HERE DOES, >, @ (DOS ;  DUP =, `OPEN $3D02 ,                    DUP =, FREAD  $3F00 ,                                           DUP =, FWRITE  $4000 ,  DUP =, `SEEK   $4200 ,                      =, `CREATE $3C00 ,                                          HERE DOES, >, @ PUSH D0 ROT POP (DOS ;                          DUP =, `SIZE  $4202 ,   DUP =, `POSF  $4201 ,                       =, FCLOSE $3E00 ,                                                                                                                                                                                                                                           : =" '" WORD CSTR                                               : >ZSTR { A L - ZA } NPAD (S! SWAP 0 : SWAP! SWAP ! ;           : ;File CSTR >ZSTR 1+ D0 EX IO? _AX ;                           : FOPEN ;File  `OPEN ;        : FCREATE ;File `CREATE ;         : `BACK! @+ XCHG EXECUTE POP !- DROP; ,<                        : 0; 0?SKIP DROP; RDROP ;                                       ' `_VAR    HERE #DOES 1- CALL, >, `BACK! !+ ;                   HERE #DOES 2- CALL, >, `BACK! : @- 2- DXEP @ ;                  =H HANDLES , , , HERE 2+ , 20 ALLOT                             : `NOEOS 0 TO EOS? ;  0 QUAN `FBUF                              : FHTOP AT HANDLES @ 2- @ ;  \ SOMETHING                        : FGET `FBUF CALL -1 TO EOS? DROP  cr ;THEN  \ IF EOF THEN EOS    AT `FBUF 1 FHTOP FREAD  _AX 0;  \ SOMETHING                     DROP `FBUF  DUP eof XOR 0; RDROP  ; \ CONTROLS - LIKE BL                                                                                                                                      : `KEY!  LIT FGET TO KEY ;                                      : ;FILE TO HANDLES `NOEOS  AT KEY @ XCHG PUSH `KEY!                  EX `NOEOS  POP TO KEY      : `CLOSE1 HANDLES FCLOSE ;      : ;TI 0 : ;TIBLK BLK XCHG LTIB PUSH ETIB PUSH PUSH                CALL EX POP POP POP THEN  TO BLK TO LTIB TO ETIB              : INVALIDATE? BLK 0; 0 TO ETIB ;                                : INCLUDE TOKEN? : INCLUDED FOPEN \` ;FILE D0 ;TI                    BEGIN vINIT EVAL EOS? UNTIL ;                              : FTYPE TOKEN? FOPEN ;FILE BEGIN KEY EMIT EOS? UNTIL ;          : M: ';  : ?M: CREATE (?",) DOES>     \ MACROSES                : SEVAL CSTR : STREVAL ;TI ETIB LTIB EVAL ;                                                                                                                                                                                                                                                                                                                                                     : 2/ 2 : U/ U/MOD NIP; ,<                                       : CLOSE_ALL    AT HANDLES @+ - 2/ LOOPS `CLOSE1 ;               : (ERR  CR  TBUF ID.  STATE ".  CR  LIT (BK TO KEY                    CLOSE_ALL  BLK 0; BLK TO SCR LTIB NEG                     : >XY 1K 1- AND TO XY ;                                           META (ERR vERR                  \ SHOW ERROR ROUTINE                                                                          0 =, BYE                                                        LIKE ;DPUSH =, `;HOME  : HOME D0 : @XY BB>W D0 $200 (VID ;      : PAGE `;HOME  25 : CRS  LOOPS CR ;                                                                                             META @OK vOK.                                                   META (AC ACCEPT    META (BE  EMIT   INCLUDE COMMON.NVF                                                                                                                                                                                                          \ ------------------------------------------------------------- : MRK>` HERE : Z, 0 , ; : RLS>` HERE  SWAP! ;                   : CODE: HERE 2+ =, ; : SHORT? DUP -$80 $80 WITHIN ;             LIKE ;` =, DOES>` >, `;code DOES, ,<     { WE HAVE DOES !}      : (",)  '" : (?",)   WORD       { PARSE & COMPILE STR     }     : CSTR, CSTR                    { COUNTED STRING COMPILE  }     : STR, ;HERE (S! DROP; ,<       { ADR COUNT STRING COMPILE}           : `>IP+ NOT 3  AND 2* POP + PUSH ;    : COMPILE @R+ , ;   LIKE :  =, CONST   LIKE bl , ,' , { CONSTANTS}                  LIKE :  =, CREATE  ' KEY 2+ 2+ @ ,  Z,  { RETURNS ADDRESS}      { READ , COMPILE WORD AT ADDRESS & POSITIONING TO NEXT}         : W, STR : A, 3 OPER[] @EXEC ;                                  : (:) CREATE DUP C, `>IP+ , , , ,'       { THE MAKER !!!}               DOES> CSTR =H `>IP+ W, W, W, @EXEC ;                    : (,) CREATE , DOES> @ , ; : BEGIN` HERE ; : >BEGIN` , ;                                                                        \ ------------------------------------------------------------- : (=) =H COMPILE ,< LIKE ;` , >, , , ; { commaers & DOERS}       ' bs  @@                 2 (:) CONST.C C,                      : STK, TUCK , , , ; ' HANDLES @@@   3 (:) STACK STK,              LIKE vERR   1 (:) DEFER ,     ' HERE @@     2 (:) VALUE ,     ' KEY @@@  3 (:) VQUAN ,        ' vINIT @@    2 (:) POINT  ,    'TO HERE @  LIKE vERR   1-   2 (:) VECTOR ,                     ' KEY @@@ DROP LIKE bl  2-   3 (:) QUAN ,                                                                                       0 VECTOR `vCREATE                                               : FAMILY   ;2DROP ' TO `vCREATE LOOPS DUP PUSH OVER + POP        ;2DROP LTIB TOKEN? 1+ @ $2D2D XOR 0;  RDROP TO LTIB `vCREATE ;                                                                 H>      0 VALUE XK      : WHAT? 7 EMIT ;         0]>            SWAP TO XK CSTR 2DUP XK BSCAN 1+ 2* + + @EXEC ; =: XK!   <H                                                                       TBL TIB +  TBUF  STACK CSTK        ' >BEGIN` =: <RELEASE      : CSWAP` CSTK CSTK SWAP TO CSTK  TO CSTK ; : CASE` 0 TO CSTK ;  : CSWAP` CSTK CSTK SWAP TO CSTK  TO CSTK ; : CASE` 0 TO CSTK ;  : <RELEASE> <RELEASE : RELEASE> HERE CSTK ! ;                   : MARK> HERE TO CSTK  Z, ;     : >MARK< MARK>  : <MARK BEGIN` ; ' MARK>      '     (IF (=) IF`          ' RELEASE> =: THEN`     ' >MARK<   ' (FOR (=) FOR`      ' <RELEASE> ' (NEXT (=) NEXT`   ' <MARK    ' PUSH (=) FOR>`     ' <RELEASE  ' (NEXT (=) <NEXT`  ' MARK>    ' (CALL (=) CALL`    ' <RELEASE  ' (JUMP (=) AGAIN`  ' <RELEASE ' (IF (=) UNTIL`     ' MARK>     ' (JUMP (=) AHEAD`  ' MARK>    ' (#IF (=) #IF`      ' MARK>     ' (OF   (=) OF`     : REPEAT` AGAIN`  THEN` ;          ' IF`   =: WHILE`            : ELSE`   AHEAD` CSWAP` THEN` ;    ' ELSE` =: ENDOF`            : ;CASE` COMPILE DROP BEGIN CSTK #IF TO CSTK THEN` REPEAT DROP   ;     ' RELEASE>   ' EXIT    (=) ;THEN`                                                                                        : M: ';  : ?M: CREATE (?",) DOES> SEVAL ; { MACROSES }            M: -IF` DUP 0< IF;                                                                                                            ' (",) ' ("   (=) "`    { STRING LITERALS  COMPILER      }      ' (",) ' (A"  (=) A"`   { STRING ERROR MESSAGES  COMPILER}      ' (",) ' (."  (=) ."`   { STRING LITERALS OUTPUT COMPILER}      : IS_SHORT? SHORT? 0= A"  SHORT!" ;                             : C,R HERE 1+ - IS_SHORT? C, ;                                                                                                  : -:  ' , C,  XK 2+ DUP TO XK       { BYTES FOR MOVE UP 1 }              HERE OVER - DUP PUSH       { START ADDRESS    }                 DUP 1+ ROT                 { PREPARE FOR MOVE }                 CMOVE>  HERE C@ POP C!   ; { FIX CODE  }               : SWITCH: CREATE HERE 73 1 TO XK 0 -: LIT    XK!     TOBE ;     : ;SWITCH  73 - A" BAD KEYS" XK 2/ 1- SWAP C! ;                                                                                 \ PUSH POP J + 2/ (IF (NX- @R+ !+ (BR DUP ; | XA XR NAND !R+    M: RSKIP` @R+ DROP; M: RDROP` POP DROP; M: M@` @R+ RDROP;       M: R1-` FOR? THEN;                                               0 VALUE AR     : `(NX- POP POP 1- PUSH PUSH @R+ J AHEAD        : `(-IF @R+ OVER  THEN  $8000 AND IF DROP; THEN XCHG DROP ;     '(, `(-IF (-IF`  ' `(NX- IS (NXT`       : -IF` (-IF` MARK>` ;                                                                   0]> ; IS (VAR`   '(, . .  '(, 2/ 2/  : 2* DUP : + + ;           : (LIT @R+ ;     META (LIT  #,`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 '(, EMIT EMIT                                                   '(, DICT DICT                                                                          : NAND AND NOT ; '(, @R+ @R+  : I J ;    '(, XCHG XR '(, DUP DUP  '(, LTIB LBUF 'TO LTIB DEFER >LBUF     '(, SOURCE SOURCE  '(, ?? ??  '(, #?? #??  '(, SHN SHN          : XA POP AR XR TO AR PUSH ; : !R+ XR POP POP !+ PUSH PUSH ;     0 VALUE BASE                                                                    ' AR TO T-LO                                    : A@ XA I XA ;; : A! PUSH XA : RDR; POP : DROP IF THEN ;        CR HERE ' AR - .  .(  AR )                                                                                                                                                                                                                                                                                                                                                                                                                                      : @I J : @ PUSH : (@ @R+ RDR; ; : EX POP XR PUSH ;              : TWICE I : EXEC PUSH ;  : @EXEC @ EXEC ;     : ;DROP EX DROP ; : (@& M@ : & NAND : ~ DUP NAND ; : (@+ M@ + ;      : (@^ M@     : XOR PUSH DUP PUSH J NAND DUP XR NAND POP POP NAND NAND ;      : (@Q RSKIP : (@V RSKIP (@ ; : !I J : ! PUSH : (! !R+ RDR; ;    : SIGN? DUP : &SIGN (@& ,< $8000 , : (!Q RSKIP : (!V RSKIP (! ; : ;NIP  EX : NIP PUSH DROP POP : NOP ;                : C@I J   : C@ ;NIP : CSTR PUSH @R+ R1- XR POP : &BYTE (@& ,< 255 ,       : 0>=; &SIGN  : 0; RDR; ?; ; : 0<; &SIGN : 0<>; NOP ?; RDR; ;   : ;SIGN? 0; EX : SGN^ (@^ ,< $8000 ,    : !+ PUSH !R+ POP ;     : (LARY 2* : (WARY 2* : (BARY POP + ;   : @+ PUSH @R+ POP ;     : ABS SIGN? 0; : NEG ~ : 1+ (@+ ,< 1 ,  : - NEG + ;             : = - : 0= IF : ZERO (@ ,< $0 ,         : `U<? POP              : < - : 0< &SIGN ZERO ?; : MONE THEN (@ ,< -$1 ,                : U< PUSH DUP I XOR 0< `U<? ?; DROP POP 0< ;                     HERE ' @I - . .(  @I ) CR                                      : .RSKIP; DROP RSKIP ; : ZSKIP .RSKIP; #?; ;                    : DXEP+ 1+ : DXEP DUP : XEP XR EXEC : (V POP ; : 1H (@ ,< 16 ,  : ;SWAP EX : SWAP PUSH : XPOP; XR POP ; : STR PUSH @R+ XPOP; ;  : ;@! XR PUSH J @ EX POP ! ; : INC ;@! 1+ ;                     : &HBYTE (@& ,< -256 , : DEC ;@! : 1- (@+ ,< -1 , : 2+ (@+ ,< 2  , : (@R @R+ J + @ ; : (!R @R+ J + ! ;  : 0SWAP ZERO SWAP ;     : TUCK SWAP  : OVER PUSH DUP XPOP; ;  : 2DUP OVER OVER ;        : (* 0SWAP : (*/ A!  : LP1H 1H  : LOOPS FOR J EXEC NEXT         : 2RDROP;  POP : .RDROP; POP : 2DROP NAND : DROP; DROP ;        : ;MAX 2DUP EX IF XEP THEN DROP ;       : UMAX ;MAX U< ;        : OR ~ PUSH ~ POP NAND ;                : UMIN ;MAX U< 0= ;     : `CRY?  2DUP UMAX XEP 2DUP + ; : WITHIN OVER - PUSH - POP U< ; : +2/ `CRY? U< PUSH + DUP POP     : ASR? ;SIGN? 2/ ;            : D2* + :;   2* XEP : M2* DUP  : UM+ +2/ 0<  : ODD (@& ,< 1 ,    HERE ' .RSKIP;  - .  .(  .RSKIP; ) CR                                                                                          : U* ;DROP : UM* (*                                             : +* OVER ODD DUP IF DROP AR THEN +2/ XEP ODD  ASR? ;           : UMOD ;DROP : U/MOD 0SWAP  : UM/MOD ;SWAP (*/ : -/ D2* AR NEG     UM+ IF XEP 1+ ;THEN AR + ;  : U/ U/MOD NIP ;                 : ICORA J : CORA DUP C@ 1+ : -TEXT FOR PUSH CSTR XR CSTR POP =         IF CSWAP> NEXT  THEN  2DROP POP 1+ ; : 16/MOD 1H U/MOD ; : CMOVE 2DROP :; : CMV LOOPS PUSH CSTR POP                      : C!+ PUSH &BYTE @I &HBYTE OR !R+ R1- POP ;     : C! C!+ DROP ; : ALIGN 1+ : >EVEN (@& ,< -2 ,  : ;SPC EX : SPACE 32 EMIT ;     : ALPHA 9 OVER U< 7 & + '0 + ;  : UCSTR SWAP XEP CSTR ;         : H. ;SPC : `H. 16/MOD ZSKIP RECURCE : DIG. ALPHA EMIT ;        : ((" J POP POP CSTR + ALIGN PUSH PUSH ;                        : (TYPE ((" : ". CSTR : TYPE ;DROP LOOPS CSTR EMIT ;            : ID. ;SPC ". ;  : %. ;SPC : `%. $2 U/MOD ZSKIP RECURCE DIG. ;   HERE ' U* - . .(  U* ) CR                                                                                                      : WTBL? UCSTR : SCAN PUSH XR PUSH J FOR STR J - IF CSWAP> NEXT  : `SC POP DROP J PUSH : `SC2 THEN POP XR 2DROP POP XR POP ~ + ; : BTBL? UCSTR : BSCAN &BYTE PUSH XR PUSH J FOR CSTR J -             `SC2 ?; NEXT  `SC ;        : (>NEXT CSTR + $2 + ;           : PARSE  &BYTE  PUSH  SOURCE LBUF DUP  PUSH - DUP POP I $20 =    IF NIP    FOR CSTR J = IF CSWAP> NEXT   : `PARSE; POP 1+ DUP   : `PARSE2   >LBUF RDR; ; THEN 1- DUP POP 1+ THEN  FOR CSTR J -   IF CSWAP> NEXT  DROP `PARSE; ; THEN 1-  OVER - POP RECURCE ;   : TOKEN $20     : WORD PARSE $FF00                              : S! XEP $FF UMIN J C!+ J C@ CMV NIP '` : SWAP! SWAP ! ;        : ;TFIND DICT AHEAD BEGIN POP (>NEXT THEN PUSH C@I               2RDROP; #?; DROP DUP J EXEC UNTIL POP XR 2DROP POP DUP ;       : (FND) CSTR + @ ; : C>N ;TFIND : ITOCK J (FND) = ;             : -FIND TOKEN : (FND ;TFIND ICORA ;                              HERE ' SCAN - . .(  SCAN ) CR                                                                                                  : Z-ROT ZERO : -ROT SWAP : USWAP XEP SWAP ; : ROT USWAP SWAP ;  : OVR_C@ OVER C@ ; : (BASE! @R+ TO BASE RDR; ; : `TNUM OVR_C@ :  `BAS*+ -ROT PUSH  PUSH PUSH BASE U* POP + POP POP              : STR1+ 1- XEP 1+ ; : `NBAS  ROT 1- &BYTE 1+ TO BASE Z-ROT ;    : DECIMAL (BASE! ,< 10 , : `-? OVR_C@ '- = 0; STR1+ EX XEP        NEG ; : HEX (BASE! ,< 16 , : BINARY (BASE! ,< 2 ,                     : DIG? '9 OVER U< IF 7 - THEN '0 - DUP BASE U< ;        CREATE `NTBL 4 C, '' C, '# C,  '$ C, '% C,                      : `STBL (WARY TO `TNUM TO `NBAS TO HEX TO BINARY ,<             : CNUMBER? CSTR  : NUMBER? Z-ROT DROP; #?; `-? DECIMAL    BEGIN      DROP; #?; OVR_C@ `NTBL BTBL? -IF DROP                           OVR_C@ DIG?  DROP; ?; `BAS*+ ELSE PUSH STR1+ .RDROP; #?;       POP `STBL @EXEC  THEN  DUP 0= UNTIL NIP ;                   HERE ' Z-ROT - .     HERE ' AR - DUP . .(  Z-ROT = ) 6 U/ . CR                                                                                                                                  : .( ') PARSE TYPE ;                                            \ : ,<` ZERO \ : >,  MONE \ FIND $FF00 { DICT} ;                \ : EVAL DUP >LBUF + { >ETIB} BEGIN TOKEN C@ 0;  FIND { OPER[]} \  @EXEC AGAIN ;                                                                                                                : @FIND ;TFIND : (TYPE) J (FND) @ = ;                           : .LIKE 2DROP :; ;TFIND J (FND) @ = IF J ID. J (FND) 2+               STR H. @ %.   THEN MONE ;                                 CREATE FNDTBL 3 C, LIKE ADD, , LIKE CLD, , LIKE AX| ,           : (AND OVER PUSH & POP = ;                                      : &LIKE ;DROP ;TFIND J (FND) @  FNDTBL WTBL? 1+ SWAP J           (FND) 4 + @ (AND & IF J ID. J (FND) 2+ STR H. @ %. THEN MONE ;                                                                              : TTT LOOPS  J . ; : IT ;   FORGET IT                                                                                                                                              : T @R 0 ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      \ : MOVE ;GO 2DROP LOOPS PUSH STR !R+ POP ;                     ' <RELEASE ' (IF- (=) NEXT-` : NEXT` COMPILE POP THEN` NEXT-`   COMPILE DROP ; ' MARK> ' (IF+ (=) IF+` ' MARK> ' (IF- (=) IF-`  : (IF+ 1+ @R+ OVER 1- : `(IF; IF DROP; THEN XCHG DROP; ;        : (IF- 1- @R+ OVER $8000 AND  `(IF; ;                           : NI. FOR I . NEXT ;    : SGN (@ ,< $8000 ,                                                    \                                \ [NOP]    @!PREDECR/@!POSTINCR |    1+/1-      | OFFSET !@     \ ------------------------------+---------------+-----------    \ [JUMP]/[CALL] | !R+/@R+       | [IF+]/[IF-]   | !R/@R         \ [EXIT]/[NEXT] | XA            | J             | XR            \ DUP           | PUSH          | DROP          | POP           \ +2/           | +*            | NAND          | -/            \ --------------+---------------+---------------+-----------    \ 3+4+4+2       | 3+1+1+1       | 1+1+1+1       | 1+1+1+1                                                                       \ CRY.TXT                                                       \ ----------------Branches                                      \ (->           ->          JUMP        <?> = IO                \ (;     /R     ->          EXIT                                \ (->?   N      ->          IF                                  \ (<-    /N     -> /N-1     NEXT                                \ ----------------Registers                                     \ >;  N /       ->   / N    PUSH   >R                           \ ;>    / N     -> N /      POP    R>                           \ ;%            ->          XA     XCHA                         \ ?%            ->          XCHG                                \ ----------------Transfer                                      \ !.+  N / I    -> / I+2    !R+                                 \ @.   / I      -> N / I+2  @R                                  \ ;>?  / R1 R2  -> / R2     RDROP                               \ ?;>>    / I J -> J / I J  J                                   \-----------------MATH & LOGIC                                  \ ?        N1   -> N1 N1    DUP                                 \ +2/   N1 N2   -> N3 N4    +AVG                                \ &~    N1 N2   -> N3       NAND                                \ ^     N1 N2   -> N3       XOR                                  : FOR?` (NEXT`          : MRK>` HERE 0 , ;                      : AHEAD` (JMP` MRK>` ;                                          : .FOR` AHEAD`          : BEGIN` HERE ;                         : R1-` FOR?             : THEN` HERE SWAP! ;                    : RSKIP` @R+` DROP` ;                                           : RDROP` POP` DROP` ;                                           : UNTIL` (IF` , ;                                              \ : IF` (IF` MRK>` ;                                            \ : FOR` PUSH` .FOR` SWAP ;                                     \ : NEXT` THEN` (NEXT` , ;   150 LOAD                                                                                           \ PRIMITIVES FOR VALUE VAR CONST QUAN VECTOR VQUAN  AND VALUES  M: RSKIP` @R+ DROP;   M: RDROP` POP DROP;                       : (# @R+ ;  : (? POP ; 'T (? IS (VAR`  'T (# IS (LIT` \ NUMBERS : <>0; IF   : RDROP; POP : DROP IF THEN THEN ;   \  ' DROP      : !I  J  : !  PUSH  : (!  !R+ RDROP; ;  'T (! IS (SET` \ VALUE  : @I  J  : @  PUSH  : (@  @R+ RDROP; ;  'T (@ IS (CON` \ CONST  : SWAP! PUSH : (!X  XR (! ;  : (INI POP (!X ; \ SAVE STATE      : (!2  RSKIP (! ;   ' (!2 IS (SET2` \ FOR QUAN & VQUAN          : (@3  RSKIP : (@2 RSKIP (@ ; 'T (@2 IS (CON2` 'T (@3 IS (CON3` : (>3  RSKIP : (>2 RSKIP : (> @R+ XR DROP ;  : 0; RDROP; ?; ;       'T (>2 IS (DEF2`  'T (>3 IS (DEF3`  'T (> IS (DEF` \ DEFER  : (DOS IO ,< $CD C, $21 C, $C3 C,       \ DOS INTERRUPT         : (VID IO ,< $CD C, $10 C, $C3 C,       \ VIDEO INTERRUPT       : (KBD IO ,< $CD C, $16 C, $C3 C,       \ KBD INTERRUPT                                                                                                                                           0 0 16 FAMILY  VALUE    _FR _AX _BX _CX _DX                                HERE SPTR DICT BASE LTIB ETIB CNTC BLK SCRH TH XY  \  0 CONST 0   -1 CONST -1  : ON  -1 SWAP! ;  : OFF 0 SWAP! ;   : (#|   @R+             \ |LITERAL                              : OR    OVER NOT AND XOR ;                                      : (|    @R+ OR RDROP; ;                                         : CHA   PUSH XCHA POP ;                                         : A@    XCHA I XCHA ;                                           : @A+   XCHA @R+ XCHA ;                                         : 0=SKIP DUP IF ;                                               : SKIP  DUP                                                     : .SKIP THEN BEGIN @R+ 2DROP ;                                  : 0<>SKIP DUP UNTIL ;                                           : !-    2-                                                      : !.    PUSH !I POP ;                                                                                                           : !+    PUSH !R+ POP ;                                          : +!    PUSH @I + (! ;                                          : @-    2-                                                      : @.    PUSH @I POP ;                                           : @+    PUSH @R+ POP ;                                          : STR   PUSH @R+ XPOP ;                                         : CSTR  PUSH @R+ R1- XCHG POP                                   : &BYTE (& /{ 255 , }\                                          : &HB   (& /{ -256 , }\                                         : ABS   0>=; NEG ;                                              : ?C@   DUP                                                     : C@    @ &BYTE ;                                               : ?^SIGN ODD 0; EX                                              : ^SIGN (^ /{ $8000 , }\ ;                                                                                                                                                                      : (LCALL @R+ PUSH ;                                             : (;GO  @R+ XCHG PUSH ;                                         : (LJUMP @R+ XCHG DROP ;                                        : (VAR  POP ;           \ VARIABLE                              : ;HERE HERE EX                                                 : >HERE (!V                                                     : HERE  (@      /{ FREEMEM , }\                                 : ALIGNED ;HERE                                                 : ALIGN 1+                                                      : EVEN  (&      /{ -2 , }\                                      : (MOVE POP ;DROP PUSH                                          : (TYPE >RA! LOOPS; ;                                           : MOVE  (MOVE  @+                                               : !A+   XCHA !R+ XCHA ;                                         : <MOVE (MOVE @-                                                                                                                : !A-   XCHA R1- R1- !I XCHA ;                                  : PLACE ;DROP PUSH &BYTE DUP POP C! LOOPS CSTR                  : C!A+  &BYTE XCHA @I &HB XOR !R+ R1- XCHA ;                    : C!    A! C!A+ ;                                               : TUCK  DUP                                                     : USWAP XEP SWAP ;                                              : ROT   USWAP SWAP ;                                            : -ROT  SWAP USWAP ;                                            : U<    ;NIP                                                    : U<?   OVER NOT AVG                                            : 0<    &SIGN 0<> ;                                             : < - 0< ;                                                      : SCAN  PUSH FOR STR J XOR IF C-ROT NEXT THEN                   : SCAN; DROP POP 1+ RDROP; ;                                                                                                                                                                    : BSCAN &BYTE PUSH FOR CSTR J XOR IF C-ROT NEXT THEN SCAN; ;    : ;NIP  EX NIP ;                                                : -TEXT ?C@ 1+                                                  : CORA  ;NIP >RA! .FOR STR @A+ = IF C-ROT NEXT THEN POP 1+ ;    : (*/)  0 SWAP 16 LOOPS ;                                       : ;SWAP EX SWAP ;                                               : 0SWAP 0 SWAP ;                                                : ;DNEG 2DUP XOR PUSH ABSWAP ABS POP &SIGN 0; EX                : DNEG  ~SWAP ~SWAP                                             : D1+   ;+ XEP 1 UM+ ;                                          : M*    ;DNEG                                                   : UM*   0SWAP ;DROP 1H LOOPS                                    : +*    XEP OVER ODD DUP IF DROP J THEN                         : UD2/? +2/ XEP ?^SIGN 2/ ;                                     : D2/ 0 UD2/? ;                                                                                                                 \ ------------------------------------------------------------- : MRK>` HERE : Z, 0 , ; : RLS>` HERE  SWAP! ;                   : CODE: HERE 2+ =, ; : SHORT? DUP -$80 $80 WITHIN ;             LIKE ;` =, DOES>` >, `;code DOES, ,<     { WE HAVE DOES !}      : (",)  '" : (?",)   WORD       { PARSE & COMPILE STR     }     : CSTR, CSTR                    { COUNTED STRING COMPILE  }     : STR, ;HERE (S! DROP; ,<       { ADR COUNT STRING COMPILE}           : `>IP+ NOT 3  AND 2* POP + PUSH ;    : COMPILE @R+ , ;   LIKE :  =, CONST   LIKE bl , ,' , { CONSTANTS}                  LIKE :  =, CREATE  ' KEY 2+ 2+ @ ,  Z,  { RETURNS ADDRESS}      { READ , COMPILE WORD AT ADDRESS & POSITIONING TO NEXT}         : W, STR : A, 3 OPER[] @EXEC ;                                  : (:) CREATE DUP C, `>IP+ , , , ,'       { THE MAKER !!!}               DOES> CSTR =H `>IP+ W, W, W, @EXEC ;                    : (,) CREATE , DOES> @ , ; : BEGIN` HERE ; : >BEGIN` , ;                                                                        \ ------------------------------------------------------------- : (=) =H COMPILE ,< LIKE ;` , >, , , ; { commaers & DOERS}       ' bs  @@                 2 (:) CONST.C C,                      : STK, TUCK , , , ; ' HANDLES @@@   3 (:) STACK STK,              LIKE vERR   1 (:) DEFER ,     ' HERE @@     2 (:) VALUE ,     ' KEY @@@  3 (:) VQUAN ,        ' vINIT @@    2 (:) POINT  ,    'TO HERE @  LIKE vERR   1-   2 (:) VECTOR ,                     ' KEY @@@ DROP LIKE bl  2-   3 (:) QUAN ,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       0 VECTOR `vCREATE                                               : FAMILY   ;2DROP ' TO `vCREATE LOOPS DUP PUSH OVER + POP        ;2DROP LTIB TOKEN? 1+ @ $2D2D XOR 0;  RDROP TO LTIB `vCREATE ;                                                                 H>      0 VALUE XK      : WHAT? 7 EMIT ;         0]>            SWAP TO XK CSTR 2DUP XK BSCAN 1+ 2* + + @EXEC ; =: XK!   <H       TBL TIB +  TBUF  STACK CSTK        ' >BEGIN` =: <RELEASE      : CSWAP` CSTK CSTK SWAP TO CSTK  TO CSTK ;                      : CASE` 0 TO CSTK ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             : <RELEASE> <RELEASE : RELEASE> HERE CSTK ! ;                   : MARK> HERE TO CSTK  Z, ;     : >MARK< MARK>  : <MARK BEGIN` ; ' MARK>      '     (IF (=) IF`          ' RELEASE> =: THEN`     ' >MARK<   ' (FOR (=) FOR`      ' <RELEASE> ' (NEXT (=) NEXT`   ' <MARK    ' PUSH (=) FOR>`     ' <RELEASE  ' (NEXT (=) <NEXT`  ' MARK>    ' (CALL (=) CALL`    ' <RELEASE  ' (JUMP (=) AGAIN`  ' <RELEASE ' (IF (=) UNTIL`     ' MARK>     ' (JUMP (=) AHEAD`  ' MARK>    ' (#IF (=) #IF`      ' MARK>     ' (OF   (=) OF`     : REPEAT` AGAIN`  THEN` ;          ' IF`   =: WHILE`            : ELSE`   AHEAD` CSWAP` THEN` ;    ' ELSE` =: ENDOF`            : ;CASE` COMPILE DROP BEGIN CSTK #IF TO CSTK THEN` REPEAT DROP   ;     ' RELEASE>   ' EXIT    (=) ;THEN`                        : M: ';  : ?M: CREATE (?",) DOES> SEVAL ; { MACROSES }            M: -IF` DUP 0< IF;                                                                                                                                                                            ' (",) ' ("   (=) "`    { STRING LITERALS  COMPILER      }      ' (",) ' (A"  (=) A"`   { STRING ERROR MESSAGES  COMPILER}      ' (",) ' (."  (=) ."`   { STRING LITERALS OUTPUT COMPILER}      : IS_SHORT? SHORT? 0= A"  SHORT!" ;                             : C,R HERE 1+ - IS_SHORT? C, ;                                                                                                  : -:  ' , C,  XK 2+ DUP TO XK       { BYTES FOR MOVE UP 1 }              HERE OVER - DUP PUSH       { START ADDRESS    }                 DUP 1+ ROT                 { PREPARE FOR MOVE }                 CMOVE>  HERE C@ POP C!   ; { FIX CODE  }               : SWITCH: CREATE HERE 73 1 TO XK 0 -: LIT    XK!     TOBE ;     : ;SWITCH  73 - A" BAD KEYS" XK 2/ 1- SWAP C! ;                                                                                                                                                                                                                                                                                 D0 3 FAMILY VALUE &OP @OP ^OP   : CR_OP CREATE , &OP , ;        : `&OP &OP EX TO &OP ;  : `FLIP CONST 2* DOES> @ `&OP XOR ;     : OP! &OP A" RESET!" HERE TO ^OP : ADR! @+ TO @OP ;             : CMR? &OP 3 AND #?? EX &OP -4 TO &OP ;                         0 1 16 FAMILY `FLIP `#B `#W `# `WR `SZ `DIR `BR `SEG `MR         `DST `SRC `OB `OW `COND `MEM `SH                               : COMMAER CR_OP DOES> &OP 3 AND A" ,SIZE!" ADR! EXEC ;          : 1PI  CR_OP    DOES> OP! C, ;                                  : 2PI  CR_OP    DOES> OP! , `MR `SRC ;                          : FIR  CR_OP DOES> ADR! HERE 2-  : XOR! DUP PUSH @ XOR POP ! ;                                                                   138 142 THRU                                                                                                                                                                                                                                                                                                                   `DIR 2 0 2 FAMILY FIR  F| T| `DIR  `SZ                          $0100 0 2 FAMILY FIR  B'|  W'|          `MR                         1 0 2 FAMILY FIR  B|  W|      `MR   `SZ   `SEG `WR  `DST    $0800 0 4 FAMILY FIR  ES| CS| SS| DS|   `SEG  `WR  `BR          $0800 0 8 FAMILY FIR  AL'| CL'| DL'|                                        BL'| AH'| CH'| DH'| BH'|    `BR   `WR               $0800 0 8 FAMILY FIR  AX'| CX'| DX'|                                        BX'| SP'| BP'| SI'| DI'|    `WR   `BR  `DST  `SRC   $0100 0 8 FAMILY FIR  AL| CL| DL| BL| AH| CH| DH| BH| `BR `WR   $0100 0 8 FAMILY FIR  AX| CX| DX| BX| SP| BP| SI| DI| `WR `MEM  $0100 0 8 FAMILY FIR  X/S X/D P/S P/D /SI /DI /BP /BX                       $600 FIR M/M     `MEM  `SRC           \    CR       `MR     $4000 0 4 FAMILY FIR  D0| DB| DW| R|  `MR \ OP_MASK .                                                                                                                                                                                                   `OW ' , COMMAER OW, `OW         `#W ' , COMMAER IW,             ' , COMMAER SG,   ' , COMMAER W,   ' , COMMAER RW,   `#W        `OB ' C, COMMAER OB, `OB  `#B ' C, COMMAER IB, ' C, COMMAER RB, ' C, COMMAER P,   ' C, COMMAER IS, `#B                                                                                          08 $06 4 FAMILY 1PI PUSH|ES, PUSH|CS, PUSH|SS, PUSH|DS,         08 $07 4 FAMILY 1PI POP|ES, `- POP|SS, POP|DS,                  08 $26 4 FAMILY 1PI ES:, CS:, SS:, DS:,                         08 $27 4 FAMILY 1PI DAA, DAS, AAA, AAS,        `SZ `#           $A8 1PI TEST#,  08 $04 8 FAMILY 1PI ADD#, ORI#,  ADC#, SBB#,                        AND#, SUB#, XOR#, CMP#,        `# `OW       02 $A0 2 FAMILY 1PI MOV|TA, MOV|FA,        `SZ `OW `SRC `WR     8 $40 4 FAMILY 1PI INC|X, DEC|X, PUSH|X, POP|X, $90 1PI XCHG|X, `#B 2 $70 8 FAMILY 1PI  JO, JC, JZ, JCZ, JS, JP, JL, JLE,        2 $71 8 FAMILY 1PI  JNO, JNC, JNZ, JNCZ, JNS, JNP, JNL, JNLE,  01 $E0 4 FAMILY 1PI LOOPNZ, LOOPZ, LOOP, JCXZ,  `#B             $EB 1PI SJMP, 02 $E4 2 FAMILY 1PI IN|P, OUT|P,                  1 $98 8 FAMILY 1PI CBW, CWD, IR2, WAIT, PUSHF,                    POPF, SAHF, LAHF,    $D7 1PI XLAT,                            $CD 1PI INT, 01 $D4 2 FAMILY 1PI AAM, AAD,                      08 $C3 2 FAMILY 1PI RET, RETF,                                  02 $A4 6 FAMILY 1PI MOVS, CMPS, `- STOS, LODS, SCAS,            $B0 1PI MOVIB,  $B8 1PI MOVIX,                                  8 $C2 2 FAMILY 1PI RET+, RETF+,                                 01 $C4 2 FAMILY 1PI LES, LDS,                                   01 $CC 4 FAMILY 1PI INT3, `- INTO, IRET,                        02 $EC 2 FAMILY 1PI IN|D, OUT|D,                                 01 $E8 2 FAMILY 1PI CALL, JMP,                                 $EA 1PI FJMP,                 $9A 1PI FCALL,                     01 $F0 6 FAMILY 1PI  LOCK, `- REPNZ, REPZ, HLT, CMC,            01 $F8 6 FAMILY 1PI  CLC, STC, CLI, STI, CLD, STD, \ ( 38FE)                                                                   $800 $80 8 FAMILY 2PI  ADDI, ORI, ADCI, SBBI,                                          ANDI, SUBI, XORI, CMPI,                  $800 $83 8 FAMILY 2PI  ADDSI, `- ADCSI, SBBSI,                                         `- SUBSI, `- CMPSI,                      $800 $10F6 6 FAMILY 2PI  NOT, NEG, MUL, IMUL, DIV, IDIV,        $800 $00FE 2 FAMILY 2PI  INC, DEC,                              $800 $10FF 4 FAMILY 2PI  CALLO, FCALLO, JMPO, FJMPO,            $F6 2PI TESTI,         $8F 2PI POP,    $30FF 2PI PUSH,          $C6 2PI MOVI,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   08 00 8 FAMILY 2PI ADD, OR, ADC, SBB, AND, SUB, XOR, CMP,       02 $84 2 FAMILY 2PI TEST, XCHG,         $88 2PI MOV,                                   $8C 2PI MOV|SG,        $8D 2PI LEA,      \ $200 0 2 FAMILY FIR  1| V|                                    $800 $D0 8 FAMILY 2PI  ROL, ROR, RCL, RCR, SHL, SHR, `- SAR,    $800 $C0 8 FAMILY 2PI  ROLI, RORI, RCLI, RCRI,                                          SHLI, SHRI, `- SARI,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    \ ADDING TO COMPILER  [ ]       \ : DO POP XCHG EXECUTE ;       : `[ STATE TO CSTK> CASE`  >, ;  : COMP?  STATE #DOES = ;       : ]` CSTK> A" PAIRS!" ;` CSTK> TO STATE  COMP? 0; THEN` ;       : [` CALL`  `[ ; : [ HERE `[ ;  : []` [` ]` ;                   EXIT                                                            {  [ IF_FUNC1 ]  [ ELSE_FUNC2 ]  CON ? }                        : ? POP POP POP ROT PUSH ROT                                          IF { TRUE}  SWAP THEN  DROP  EXECUTE ;                     [ ."  COMPILING MODE " CR ]  .( WAS) EXECUTE                                                                                    [ [ ." EQUALS " + . ]                                            [ 1 ." AND ONE " ] ." ADDITION OF " [ 2 ." TWO " ]             ]  EXECUTE                                                                                                                                                                                                                                                     : >EVEN -2 AND ;   0 VALUE aTAR  \ START OF METACOMPILER        : A>T 1+ : ADR>TOKEN 2/ : ^SIGN $8000 XOR ;  ' A>T TO v.>TOC      M: CNT!` !R 2;  M: CNT@` @R 2;                                                                                                143 LOAD                                                                                                                        : .HEAP  ."  HEAP: " DICT THERE - . ;                           : ;START  CR 0 HERE ! EX CR HERE @ . 2DROP ;                                                                                    : TARGET: CREATE >, DOES> TO aTAR  #TARGET  ;START ;FND          J (TYP = 0;  J N>C 2+ PUSH CNT@ aTAR EXECUTE RDROP                     0= 0= NEG DUP HERE +! >PRT? ;                                                                                                                                                                                                                                                                                           : CALL`  HERE TO CSTK>  -1 , ;                                  144 LOAD                                                        TARGET: .USED    >EVEN ;        TARGET: .UNUSED  >EVEN 0= ;     TARGET: .DEF     ODD 0= ;       TARGET: .UNDEF   ODD ;          TARGET: .MONO    2/ 1- 0= ;     TARGET: .MANY    4 U< 0= ;      : ?STAT2 CFA? #?? STR #TARGET - A" TARGET?" ;                   : UNDEFINE ?STAT2 : DO-UNDEF  PUSH 1 CNT! 0 POP ! ;             : .STAT ?STAT2 PUSH CR TBUF ID-. CNT@ 2/ ." USED " .              CNT@ ODD IF  ."  UN " @I BEGIN  #IF DUP H. @ REPEAT             DROP  THEN  RDROP ;                                           : .DEFINE PUSH @I HERE v.>TOC POP ! DROP; #?; RECURSE ;                                                                                                                                                                                                                                                                                                                                         : :T >, : :TT ALIGNED  LTIB TO >LTIB< CFA? IF 2+ PUSH  \ FOUND    CNT@ ODD 0=  A" DUPLICATES"  CNT@ 1- CNT!  ALIGNED              POP .DEFINE ; THEN >LTIB< TO LTIB DROP                        : HEADER HERE v.>TOC HERE $8000 U< IF ;T>< (,) ;THEN 3 + (,) ;                                                                  : F: 1 0 (T) ;  \ FORWARD DEFINITIONS                                                                                           M: RSKIP` @R+ DROP;   M: RDROP` POP DROP;  ': ?M: R;` RDROP; ;: M: R1-` FOR? THEN ;                        ': ?M: X;` XPOP; ;:  : (A,)   1 A" DESTINATION? " ; \ ,  H.-@ 2* e?RANGE ;           : BLOAD  TOKEN?  : "BLOAD FOPEN ;FILE FHTOP FREAD ;             : (:HEADER LIT HEADER LIT TO (: ! ;                             M: DROP` IF THEN;  M: TWICE` CALL THEN; M: NOT` DUP NAND;                                                                                                                                                                                                       : TO`  ?STAT2 @ 1+ , ;          : AT`  ?STAT2 @ 2+ , ;          : RECURSE` ;, LATEST 2+ @ ;                                     DO HIDE 5 TIMES   @R` !R` (@R (!R DOES>`                        DO F:   4 TIMES   (!R (@R ;code  !R-                            #DO (,) 1 TIMES   0 SKIP                                                                                                        : DOES>`  ;code` ;                                              : @R` (@R` ,NUM? ;                                              : !R` (!R` ,NUM? ;                                                                                                              \ 237 LOAD                                                                                                                      \ HEADER IS (:          \ FRGSDFG                                                                                                                                                                                                                               ' 0<   TO vIS:?    ' 2* TO vTOC>.  \ ' T?ID. 2+ TO vDBG                                                                          8 1K U* VALUE BASE-ADR         \ BLOAD \ FILE TO MEM LOADER    : PRIMITIVE 2* BASE-ADR + $100 - 2/ IS ;     \  : `:=? @ 0< ;                                                                   \ CR .( HIDES )                                                 DO HIDE  27 TIMES  RDROP SWAP ;LIST  ;LIST :  :` (CALL`           LIT  EXIT DROP (IF (JUMP ;GO (#IF  (NEXT PUSH (CALL             (OF  POP  J    ("  (A"   (." SKIP  RDROP EX  EXIT  \ .( H1 )                                                                  \ CR .( HIDE-TEST )                                             DO HIDE-TEST  25 TIMES   ;LIST  DROP  :   :`  (CALL`              LIT  EXIT DROP (IF (JUMP ;GO (#IF  (NEXT PUSH (CALL             (OF  POP  J    ("  (A"   (." SKIP  RDROP EX   SWAP  \ .( H2 )                                                                                                                                 \ HIDE WORDS & TEST HIDING                                      DO UNDEFINE 19 TIMES   (#IF  (OF  (CON  (LIT   (VAR               (DEF  (SET  (CON2  (STK>  (>STK  (DEF2  (DEF3  (SET2            (CON3  (EMT  ("  (A"  (."  ;GO                                                                                                \ CR .( UNDEFINED ) .UNDEF                                                                                                      #'T'; -FIND X` `ROP 1+ !         \ CHANGE THE NAME OF X` TO ;T  ' :T =: :       ' :TT =: :`     HIDE :T         HIDE :TT                                                                        PRUNE                                                                                                                           \ CR .(   HIDE-OK-? )                                           CR .( START METACOMPILING...) CR                                                                                                                                                                 BASE-ADR 178  BLOAD C4F.COM  BASE-ADR 178 + TO THERE           { CR CR   .UNUSED   .UNUSED}  ZDO (,) 15 TIMES  ABORT DUP EX IO     NAND NOP +2/ +* @R+ !R+ -/ XA XOR XR 2/                     \ CR CR .( .UNUSED2 ) .UNUSED                                   #DO PRIMITIVE 23 TIMES  $80 ABORT` $9B (JMP`  $9D (IF` $C6 DUP` $CF EX`   $97 ;T    $8C IO`   $C2 J`    $B3 NAND`  $A2 (NXT`    $CA NOP`  $D5 +2/`  $AA +*`   $C5 POP`  $BB PUSH`  $BF @R+`     $BD !R+` $A3 -/`  $A0 SKIP` $B7 XA`  $D2 XOR`  $B1 XR` $D7 2/`  \ <T \ CR CR .( .UNUSED3 ) .UNUSED                              : TT ABORT (JMP (IF DUP EX IO J NAND (NXT NOP +2/ +* POP         PUSH @R+ !R+ -/ SKIP XA XOR XR 2/ . . . ;  \ TEST DEFINITION   \ CR CR .( .UNUSED4 ) .UNUSED                                   BASE-ADR TO T-LO   ' (A,) 3 OPER[] !                            <T    \ COMPILE ON TARGET NOW                                   (:HEADER                                                                                                                        \ N STACK+ NAME | CURRENT  LO-END HI-END | I-1 .. I-N  | ITEMS  2 CONST CELL    : `CLARY XEP RES>` RES>` CLARY ;                M: CELL+ 2+;   M: CELL- 2-;    M: CELLS 2*;    M: >CELLS 1+ 2/; : !BOTTOM CELL+ DUP !- DROP ; : @TOP @ @- DROP ;                : ITEMS? @+ @ - 2/ ;                                            : `?@BOUNDS @+ @ : `?BOUNDS WITHIN 0= A" BOUNDS!" ;                                                                             : ;STK `?@BOUNDS : ;@! @+ XCHG EXECUTE POP !- DROP; ,<          : `CELLSTK, CELLS        MRK>` MRK>` MRK>` `CLARY RES>` ;       $40E    1]> DUP @+ ;STK !+ ;    2]> DUP STR 2- SWAP ;STK @- ;     3 (:) STACK+ `CELLSTK,                                                                                                                                                                                                                                                                                                                                                                        : WTBL? SUCSTR : SCAN PUSH XR PUSH J FOR STR J - IF CSWAP> NEXT : `SC POP DROP J PUSH : `SC2 THEN POP XR 2DROP POP XR POP ~ + ;  : BTBL? SUCSTR : BSCAN &BYTE PUSH XR PUSH J FOR CSTR J -           `SC2 ?; NEXT- `SC ;        : (>NEXT CSTR + $2 + ;           : ;TFIND  DICT AHEAD BEGIN POP (>NEXT THEN PUSH C@I              2RDROP; ?; DROP DUP J EXEC 0= UNTIL POP XR 2DROP POP DUP ;     : (FND CSTR + @ ; : TFIND ;TFIND : ITOCK J (FND - ;             : @FIND ;TFIND J (FND @ - ;     : ;CR EX CR ;                   : .LIKE ;GO 2DROP ;TFIND J (FND @ = IF J ID. J (FND 2+                STR H. @ H.   THEN -1 ;         : VARIABLE CREATE  0 , ;  : ASET, CELLS PUSH HERE 3 CELLS + DUP I + STK, POP ALLOT ;      ' HANDLES @@@ 3 (:) SET ASET,  : !SET DUP 2 CELLS + @ SWAP! ;   : ICORA J : CORA DUP C@ 1+ : -TEXT FOR PUSH CSTR XR CSTR POP =         IF CSWAP> NEXT- THEN  2DROP POP 1+ ; : 16/MOD 1H U/MOD ; : @ITEM CELLS @R+ EXEC @ + @ ; : -FIND TOKEN? ;TFIND  ICORA ;   153 205 THRU                                                    ' DEFER DEFER ALIAS  ' XCHG ALIAS XR  ' NOT ALIAS ~  : @I J @ ; : ( ') WORD DROP ;      ' ( ALIAS (`    : REQUIRE ' DROP ;      ' I ALIAS R@    ' 2+ ALIAS CELL+        ' PUSH ALIAS >R         ' POP ALIAS R>  ' 2* ALIAS CELLS        ' DICT ALIAS STARTVOC   ' STR ALIAS @+  ' NOT ALIAS INVERT      : C@I J C@ ; : NOP ;    0 CELL+ CONST CELL      : I+C@ J + C@ ; CELL 1- CONST &CELL     : 2RDROP; POP POP : 2DROP 2DROP; ; : REMEMBER` HERE 3 - SWAP! ; \ : CREATE BLK , CREATE ;                                         : WAS ' 2+ @ ;                                                : B>> LOOPS : 8>> bs : >> LOOPS 2/ ;                            : B<< LOOPS : 8<< bs : << LOOPS 2* ;                                                                                                                                                                                                                                                                                                                                                            \ ASGEN.NF                                                      ( $Id: asgen.NF,  V 4.27 2004/06/14 22:02:23 albert Exp $ )     ( Copyright 2000 Albert van der Horst, HCC FIG Holland by)      ( GNU Public License Uses Richard Stallmans convention.)        ( Uppercased word are parameters.    )                                                                                          ( REVERSE ENGINEERING ASSEMBLER  cias cidis                 )                                                                   ( This file `asgen.frt' contains generic tools and has been)    ( used to make assemblers for 8080 8086 80386 Alpha 6809 and)   ( should be usable for Pentium 68000 6502 8051. It should run)  ( on ISO Forth's provided some ciforth facilities are present)  ( or emulated. The assemblers -- with some care -- have the)    ( property that the disassembled code can be assembled to the)  ( exact same code.            )                                                                                                 ( Most instruction set follow this basic idea that)             ( it contains of three distinct parts:                     )    (   1. the opcode that identifies the operation            )    (   2. modifiers such as the register working on           )    (   3. data, as a bit field in the instruction.            )    (   4. data, including addresses or offsets.               )    ( This assembler goes through three stages for each)            ( instruction:        )                                         (   1. postit: assemblers the opcode with holes for the)        (      modifiers. This has a fixed length. Also posts)          (      requirements for commaers.   )                           (   2. fixup: fill up the holes, either from the beginning or)  (      the end of the post. These can also post required)       (      commaers)                                                                                                                                                                                (   3. fixup's with data.It has user supplied data in addition)                                                                 (      to opcode bits. Both together fill up bits left by a)    (      postit.)                                                 (   4. The commaers. Any user supplied data in addition to    ) (      opcode, that can be added as separate bytes. Each has a) (      separate command, where checks are built in.           ) ( Keeping track of this is done by bit arrays, similar to the)  ( a.i. blackboard concept. This is ONLY to notify the user of)  ( mistakes, they are NOT needed for the assembler proper.    )  ( This setup allows a complete check of validity of code and)   ( complete control over what code is generated. Even so all)    ( checks can be defeated if need be.            )                                                                                                                                                                                                               ( The generic tools include:                                  ) (   - the defining words for 1 2 3 4 byte postits,            ) (   -                    for fixups from front and behind     ) (   -                    for comma-ers,                       ) (   - showing a list of possible instructions, for all opcodes) (   -  or for a single one.                                   ) (   -  disassembly of a single instruction or a range         ) (   - hooks for more tools, e.g. print the opcode map as)       (        postscript.    )                                       (   - hooks for prefix instructions                           ) (   - hooks for classes of instructions,)                       (        to be turned off as a whole                             To write an assembler, make the tables, generate the complete   list of instructions, assemble it and disassemble it again. If equal, you have a starting point for confidence in your work. )                                                                 ( This code was at some time big-endian dependant and assumed)  ( a 32 bit machine!It is not sure that all traces of this have) ( vanished.You cannot use this program as a cross-assembler if) ( there are instructions that don't fit in a hosts cell)        ( {Its postit that is.}     )                                   ( IT USES THE VOCABULARY AS A LINKED LIST OF STRUCTS: ciforth!) ( IT USED KNOWLEDGE OF THE INTERPRETER AND THE HEADERS!       ) ( Now if you think that this makes this code non-portable,)     ( think again. You have to change about 8 lines to adapt. Now)  ( if you only have to adapt 8 lines in a 40k lines c-program)   ( with the same functionality,   )                              ( it would smack portable. Wouldn't it?)                        ( The blackboard consist of three bit arrays. At the start of)  ( an instruction they are all zero. `TALLY-BI' `TALLY-BY')      ( `TALLY-BA' keep track of instruction bits, instruction byte)  ( and bad things respectively.                               )  ( An instructions generally has a single postit that defines)   ( the opcode.It assembles the opcode, advancing `HERE' leaving) ( zero bits that needs still filling in by fixups. It sets)     ( these bits in  `TALLY-BI'.It may also post that commaers are) ( required by setting a bit in `TALLY-BY'.                    ) ( Then comes the fixups. They fill up the holes left in the   ) ( instruction -- before `HERE' -- by or-ing and maintain)       ( `TALLY-BI' , resetting bits. They end in `|' where the other) ( assembly actions end in `,'. They may require more commaers,) ( posting to `TALLY-BY'.The commaers advance `HERE' by a whole) ( number of bytes assembling user supplied information and)     ( reset the corresponding bits in `TALLY-BY'.  )                ( All parts of an instruction can add bits to `TALLY-BA'. If)   ( any two consecutive bits are up this is bad. Its bits can)    ( never be reset but `TALLY-BA' is reset as a whole at the)     ( start of an instruction.        )                             ( An example: load an index register with a 16 bit value, 8080) ( TALLY-BI TALLY-BY TALLY-BA HERE     8A43 4  DUMP  )           ( 0000     0000     0801     8A43     .. .. .. ..    LXI,     ) ( 0030     0002     0002     8A44     01 .. .. ..    SP|      ) ( 0000     0002     0002     8A44     31 .. .. ..    SP0 @ X, ) ( 0000     0000     0002     8A46     31 00 FE ..    HLT,     ) ( 0000     0000     0000     8A47     31 00 FE 76    ...      ) ( The bit in `TALLY-BA' means a 16 bit operation. Now if)       ( `TALLY-BA' contains 3 it would mean that it is at the same)   ( time an 8 bit and 16 bit operation. Bad!                    ) ( The following problems can be detected:                     ) ( - postit when `TALLY-BI' or `TALLY-BY' contains bits up     ) ( - setting or resetting bits for the second time in `TALLY-BI) (      or `TALLY-BY'                                          ) ( - commaing when `TALLY-BI' still contains bits up           ) ( - setting `TALLY-BA' bad                                    ) ( A prefix PostIt has its prefix field filled in with an)       ( execution token. This token represents the action performed)  ( on the TALLY-BA flags, that is used instead of resetting it.) ( This can be used for example for the OS -- operand size --)   ( prefix in the Pentium. Instead of putting the information)    ( that we are in a 16 bit operand segment    )                  ( in TALLY-BA , it transforms that information to 32 bit.     ) ( ############### PRELUDE ####################################) ( Wrapper for asgen, when we want to test without label)        ( mechanisms. These are hot patched for reverse engineering. )  REQUIRE ALIAS                                                   '   HERE  ALIAS AS-HERE         '   C,    ALIAS AS-C,           '  ALLOT  ALIAS AS-ALLOT        'AT HERE  ALIAS _AP_            : ADORN-ADDRESS DROP CR ;                                       ( Action between two disassembled instr.    )                                                                                   ( ############### PART I ASSEMBLER ###################### )     ( MAYBE NOT PRESENT UTILITIES                              )    \ REQUIRE !CSP     \ To counter design error to eliminate it.   \ REQUIRE @+                                                    ( Fetch from ADDRES. Leave incremented ADDRESS and DATA )       \ : !+ >R R@ ! R> CELL+ ;                                       ( Store DATA to ADDRES. Leave incremented ADDRESS)              ( Fetch from decremented ADDRES. Leave DATA and ADDRESS)        \ : @- 0 CELL+ - >R R@ @ R>  ;                                  ( CHAR - CONSTANT &-     CHAR ~ CONSTANT &~                 )   CELL BARY `BTABLE 1 , 1 ,                                       ( x TABLE + @ yields $100^[-x mod 4]  Rotate X by I bytes)      : ROTLEFT &CELL AND CELL+ `BTABLE @ UM* OR ;                    : XREVERSE XEP : REVERSE-BYTES 0 `BTABLE ! 0                          CELL LOOPS 8<< CELL 1- J - `BTABLE C@ OR ;                                                                                ( ------------- UTILITIES, SYSTEM DEPENDANT -----------------)  ( left leaving X' Left i.e. such as it appears in )             ( memory! Not as printed on a big endian machine! )             ( aqa " 8 * LSHIFT" on bigendian. )     \ 'TABLE HIDDEN                                                                         \ VOCABULARY ASSEMBLER IMMEDIATE   ASSEMBLER DEFINITIONS HEX    ( We use the abstraction of a dea "dictionary entry address".)  ( aqa "xt"  Return the DEA from "word". 1]                   )  \ DENOTATION : % POSTPONE ' ; PREVIOUS  \ NFA LFA ^CFA BODY     0 0 3 FAMILY VALUE  LPTR DPTR HPTR                              : `CRT HERE TO HPTR 0 , HERE LPTR , TO LPTR DICT TO DPTR ;      : CREATE-- `CRT CREATE DICT HPTR ! ; : `+OFS CONST DOES> @ + ;  CELL `+OFS L>CF    -2 CELLS `+OFS C>LF  -1 CELLS `+OFS L>NF     CELL `+OFS N>LF    1 CELLS `+OFS C>BF   -1 CELLS `+OFS B>CF                                                                                                                                     : %ID.  L>NF @ ID. ;   \ : %ID. >NFA @ $@ TYPE SPACE ;          ( Print a definitions name from its DEA.)                       \ : %>BODY L>BF ; ( From DEA to the DATA field of a word )      \ : %BODY> B>LF ; ( Reverse of above)                           \ : %>DOES >DFA @ ; From DEA to the DOES> pointer for a `DOES>' \ word. Leave for DEA : it IS to be ignored in  disassemblies.  \ This is used for supressing the bare bones of the sib         \ mechanism in i586.)                                           : IGNORE? L>NF @ 1+ C@ '~ = ;                                   : VOCEND? @ 0= ;   \ : VOCEND? >LFA @ 0= ;                      : >NEXT% @ ;                                                    ( Given a DEA, return the next DEA. For a DEA as returned)      ( from (>NEXT%} : it IS the end, not a real dea.  )             \ : STARTVOC ['] ASSEMBLER >WID >LFA @ ;                        : STARTVOC LPTR ;                                                                                                               \ : >NEXT% BEGIN  (>NEXT%) DUP >NFA @ CELL+ C@ &- - UNTIL ;     \ : >NEXT% BEGIN  (>NEXT%) DUP >NFA @ 1+ C@ '- - UNTIL ;        \ As (>NEXT%} but skip holes, i.e. words with names starting in \ ``-''  Leave the first DEA of the assembler vocabulary.)      ( Build: allocate place to remember a DOES> address of a)       ( `CREATE'd word  Leave that ADDRESS  to be filled in by)       ( ``REMEMBER'' Execution: Leave for DEA : it IS of same type)   ( as the remembered DOES> )                                     \ : %>DOES 2- ;                                                 : IS-A CREATE HERE 1 CELLS ALLOT DOES> @ SWAP ( %>DOES) @ = ;   ( Patch up the data field of a preceeding word defined by)      ( `IS-A' To be called when sitting at the DOES> address  )      ( The !CSP / ?CSP detects stack changes.)                       ( Now split it into 2 checks.    )                                                                                                                                                              \ : REMEMBER  ?CSP HERE SWAP ! !CSP ; IMMEDIATE                                                                                 : ?ERROR DROP DROP ; ( Also needed : ?ERROR  )                  (   `` : ?ERROR DROP DROP ; '' defeats all checks.           )                                                                  ( Behaves as ``CREATE'' except, if the word to be created has)  ( name "--" it is ignored, by making the header unfindable.)    ( Not strictly needed.  )                                       \ REQUIRE POSTFIX                                               \ : CREATE--   (WORD) 2DUP POSTFIX CREATE                       \     2 = SWAP "--" CORA 0= AND IF LATEST HIDDEN THEN ;                                                                                                                                                                                                                                                                                                                                         ( ------------- UTILITIES, SYSTEM INDEPENDANT ------- )         ( Note that the assembler works with multi-character bigendian) ( numbers  The FIRST bitset is contained in the SECOND one,)    ( leaving it IS      )                                          : CONTAINED-IN OVER AND = ;                                     ( Compile the ls 8 bits of X at here,leaving the REMAINING bts) : lsbyte, DUP AS-C, 8>> ;                                       ( For X and ADDRESS , add the byte below address to x at)       ( l.s. place.    Leave X and decremented ADDRESS.       )       \ : lsbyte@ 1- SWAP 8 LSHIFT OVER C@ OR SWAP ;                  ( For X ADDRESS LENGTH , return the NUMBER that at address)     ( {bigendian}. x provides a filler, -1 results in sign)         ( extension. )                                                                                                                                                                                                                                                  : MC@ 0 : -MC@ -ROT                                             : lsbytes SWAP PUSH FOR 8<< J I+C@ OR NEXT RDROP ;              \ : lsbytes  >R R@ + BEGIN R> DUP                               \            WHILE 1- >R  lsbyte@ REPEAT 2DROP ;                ( For ADDRESS LENGTH , return the NUMBER that is there)         ( {bigendian}. "Multiple byte fetch".                  )        \ : MC@ 0 : -MC@ -ROT lsbytes ;  \ : MC@ 0 ROT ROT lsbytes ;    ( For ADDRESS LENGTH , return the "number there IS negative" )  : MC<0? 2DUP : MC<0 + 1- C@ $80 AND $80 = ;                     ( For ADDRESS LENGTH , return the NUMBER that is there. )       ( Bigendian andsignextended.  "Multiple byte fetch, signed". )  \ : MC@-S 2DUP MC<0 ROT ROT lsbytes ;                           : MC@-S MC<0? -MC@ ;                                                                                                                                                                                                                                            ( ------------- ASSEMBLER, BOOKKEEPING -----------------------)                                                                 ( The bookkeeping is needed for error detection & disassembly)                                                                    ( Bits that needs fixed up)                                   VARIABLE TALLY-BI                                                 ( Bits represent a commaer that is to be supplied)            VARIABLE TALLY-BY                                                 ( State bits, bad if two consequitive bits are up)            VARIABLE TALLY-BA                                               ( Bits set in the default can be used to exclude certain)       ( classes of instructions, e.g. because they are not)           ( implemented.     )                                                                                                                                                                                                                                            VARIABLE BA-DEFAULT    0 BA-DEFAULT !                           VARIABLE OLDCOMMA ( Previous comma, or zero)                    VARIABLE ISS  ( Start of current instruction)                   VARIABLE ISL  ( Lenghth of current instruction)                 ( To be executed instead of reset)                              ( BA between prefix and instruction )                           VARIABLE BA-XT                                                  ( Reset ``BA'' to default for begin instruction, unless prefix) : RESET-BAD   BA-XT @ DUP IF EXEC ELSE                             DROP  BA-DEFAULT @ TALLY-BA ! THEN ;                                                                                         : !TALLY   0 TALLY-BI !         ( Initialise ``TALLY'' )                0 TALLY-BY !   RESET-BAD   0 OLDCOMMA ! ;                  0 BA-XT !   !TALLY                                                                                                                                                                           ( Return: instruction IS complete, or not started)              : AT-REST? TALLY-BI @ 0=   TALLY-BY @ 0=  AND ;                 ( For N : it CONTAINS bad pairs)                                : BADPAIRS? DUP 1 << AND $AAAAAAAAAAAAAAAA AND ;                : BAD? TALLY-BA @ BADPAIRS? ;                                   ( The state of assembling IS inconsistent If STATUS were )      ( added to `TALLY-BA' would that CREATE a bad situation? )      : COMPATIBLE? TALLY-BA @ OR BADPAIRS? 0= ;                      \ DECIMAL                                                       ( Generate errors. None have net stack effects, such that )     ( they may be replaced by NULL definitions.               )     : CHECK26 AT-REST? 0= 26 ?ERROR ;  ( Error at postit time )     : CHECK32 BAD? 32 ?ERROR ; ( Always an error )                  ( Generate error for fixup, if for the BI, some of the BITS)    ( would stick out it. Leave MASK and BITS . Prog error!    )                                                                    : CHECK31 2DUP SWAP CONTAINED-IN 0= 31 ?ERROR ;                 ( Generate error for ``FIXUP-DATA'' , if the BI and the LEN)    ( are not compatible. Leave BI and LEN . Programming error!)    : CHECK31A 2DUP OVER >R >> 1  OR OVER << R> <> 31 ?ERROR ;      ( Generate error for postit, if for the inverted BI , some of)  ( the the BITS would stick out it. Leave MASK and BITS .)       ( Programming error!     )                                      : CHECK33 2DUP SWAP INVERT CONTAINED-IN 0= 31 ?ERROR ;          ( BITS would stick out it. Leave MASK and BITS . Programming  ) ( error! Generate error on data for postit/fixup, if some BITS) ( to fill in are already in the MASK. Leave BITS and MASK. )    : CHECK28 2DUP AND 28 ?ERROR ;                                  ( Generate error on data for commaer, if the BITS to reset )                                                                                                                                                                                                    ( are not present in the MASK. Leave BITS and MASK.        )    : CHECK29 2DUP OR -1 - 29 ?ERROR   ;                            ( Generate error if COMMAMASK is not in ascending order.)       ( Leave IT.      )                                              : CHECK30 DUP OLDCOMMA @ < 30 ?ERROR DUP OLDCOMMA ! ;           \ HEX                                                           ( Or DATA into ADDRESS. If bits were already up its wrong.)     : OR! >R  @I  CHECK28 OR R> ! ;                                 : OR!U >R  @I  OR R> ! ; ( Or DATA into ADDRESS. Unchecked.)    ( Reset bits of DATA into ADDRESS. If bits were already down)   ( it's wrong )                                                  : AND! >R INVERT @I CHECK29 AND R> ! ;                                                                                                                                                                                                                                                                                          ( ------------- ASSEMBLER, DEFINING WORDS    -----------)       ( Common fields in the defining words for posits fixups )       ( and commaers.   All leave a single ADDRESS.           )                                                                       ( The first data field for a postit/fixup contains instruction) ( bits, for a commaer it contains the xt of the coma action   ) ( for a data fixup it contains the position of the bits       ) \ Work on TALLY-BI etc.     posits fixups and commaers.  )      CELL `+OFS >DATA   ( Effects  |||    |||       |||       )       2 CELLS `+OFS >BI          ( OR!    AND!      --        )       3 CELLS `+OFS >BY          ( OR!    OR!       AND!      )       4 CELLS `+OFS >BA          ( OR!U   OR!U      OR!U      )       5 CELLS `+OFS >CNT         ( `HERE' advances with count )       6 CELLS `+OFS >DIS ( disassembler only for COMMA , 0 -> deflt)  6 CELLS `+OFS >PRF ( prefix flag, only for PI , 0 -> default )                                                                 ( Assemble INSTRUCTION for ``ISL'' bytes. ls byte first.     )  \ : assemble, ISL @ 0 DO lsbyte, LOOP DROP ;                    : assemble, ;DROP ISL @ LOOPS lsbyte, ;                         : !POSTIT  AS-HERE ISS !  0 OLDCOMMA ! ;                        ( Initialise in behalf of postit )                              ( Bookkeeping for a postit using a pointer to the BIBYBA )      ( information, can fake a postit in disassembling too        )  : XTALLY:, XEP  : TALLY:,   @+ TALLY-BI !                          @+ TALLY-BY !   @+ TALLY-BA OR!U  @+ ISL !   @ BA-XT ! ;     ( Post the instruction using DATA. )                            : POSTIT   CHECK26   !TALLY   !POSTIT  @+ XTALLY:, assemble, ;  ( Build an instruction given by BA BY BI the OPCODE and COUNT)  : `4N, XEP , , , , ;                                            : `CREAT CHECK33 CREATE-- EX : BUILD-IP `4N, , 0 ( prefix) , ;                                                                                                                                  ( Define an instruction by BA BY BI and the OPCODE           )  ( For 1 2 3 and 4 byte opcodes.                              )  IS-A IS-1PI     : 1PI  `CREAT 1 DOES> REMEMBER POSTIT ;         IS-A IS-2PI     : 2PI  `CREAT 2 DOES> REMEMBER POSTIT ;         \ IS-A IS-3PI     : 3PI  `CREAT 3 DOES> REMEMBER POSTIT ;       \ IS-A IS-4PI     : 4PI  `CREAT 4 DOES> REMEMBER POSTIT ;       ( For DEA : it REPRESENTS some kind of opcode.             )    : IS-PI ;DROP XEP 0    J IS-1PI OR  J IS-2PI OR ;                   \ J IS-3PI OR   J IS-4PI OR ; \ R> DROP ;                   ( Bookkeeping for a fixup using a pointer to the BIBYBA    )    ( information, can fake a fixup in disassembling too.      )    : TALLY:|   @+ TALLY-BI AND!                                       @+ TALLY-BY OR!   @ TALLY-BA OR!U ;                          ( Fix up the instruction using a pointer to DATA. )             : FIXUP>   @+ ISS @ OR!   TALLY:|   CHECK32 ;                                                                                   ( Define a fixup by BA BY BI and the FIXUP bits One size )      ( fits all, because of the or character of the operations. )    IS-A IS-xFI                                                     : xFI   CHECK31 CREATE-- , , , , DOES> REMEMBER FIXUP> ;        ( Fix up the instruction using DATA and a pointer to the bit)   ( POSITION. )                                                   : FIXUP-DATA @+ ROT SWAP << ISS @ OR! TALLY:| CHECK32 ;         ( Define a data fixup by BA BY BI, and LEN the bit position. )  ( At assembly time: expect DATA that is shifted before use   )  ( One size fits all, because of the or character)               ( of the operations.     )                                                                                                      IS-A IS-DFI                                                     : DFI   CHECK31A CREATE-- , , , , DOES> REMEMBER FIXUP-DATA ;                                                                                                                                   ( *************** OBSOLESCENT **************************    )   \ Reverses bytes in a WORD. Return IT.                          \ : REVERSE-BYTES  1 CELLS 0 DO DUP  FF AND SWAP 8 RSHIFT  LOOP \            8 CELLS 0 DO SWAP I LSHIFT OR 8 +LOOP ;            ( Rotate the MASK etc from a fixup-from-reverse)                ( into a NEW mask fit for using from the start of)              ( the instruction. We know the length!  )                       : CORRECT-R 0 CELL+ ISL @ - ROTLEFT ;                           ( Bookkeeping for a fixup-from-reverse using a pointer to the ) ( BIBYBA information, can fake a fixup in disassembling too.  ) : TALLY:|R  @+ CORRECT-R TALLY-BI AND!                             @+ TALLY-BY OR!   @ TALLY-BA OR!U ;                                                                                                                                                                                                                                                                                          ( Fix up the instruction from reverse with DATA. )              : FIXUP< CORRECT-R ISS @ OR! ;                                  ( Define a fixup-from-reverse by BA BY BI and the FIXUP bits )  ( One size fits all, because of the character of the )          ( or-operations. bi and fixup are specified that last byte is)  ( lsb, such as you read it )    IS-A IS-FIR                                : FIR CHECK31 CREATE-- REVERSE-BYTES , REVERSE-BYTES  , , ,    DOES> REMEMBER @+ FIXUP< TALLY:|R  CHECK32 ;          ( Define a fixup-from-reverse by BA BY BI and LEN to shift )    ( One size fits all, because of the character of the )          ( or-operations. bi and fixup are specified that last byte)     ( is lsb, such as you read it )                                 IS-A IS-DFIR   : DFIR   CHECK31 CREATE-- , REVERSE-BYTES , , ,      DOES> REMEMBER @+ SWAP >R << REVERSE-BYTES FIXUP< R>                  TALLY:|R  CHECK32 ;                                                                                                   ( *************** PREFERRED NOT YET USED *******************)   ( If bits were already down it is wrong. For next two words.)   ( Reset bits of DATA into ADDRESS bytewise. )                   : (AND!BYTE) >R W>B INVERT C@I CHECK29 AND R> C! ;              ( Reset bits of DATA byte by byte into ADDRESS )                : AND!BYTE BEGIN 2DUP (AND!BYTE) SWAP 8>>                                     DUP WHILE SWAP 1+ REPEAT 2DROP ;                  ( If bits were already up its wrong. for next two words.)       ( Or DATA into ADDRESS bytewise. )                              \ : (OR!BYTE) >R R@ C@  CHECK28 OR R> C! ;                      : (OR!BYTE) >R C@I CHECK28 OR R> C! ;                           ( Or DATA byte by byte from behind into ADDRESS )               : OR!BYTE BEGIN 1- 2DUP (OR!BYTE) SWAP                                     8>> DUP WHILE SWAP REPEAT 2DROP ;                                                                                                                                                    ( Bookkeeping for a fixup-from-reverse using a pointer to the ) ( BIBYBA information, can fake a fixup in disassembling too.  ) : TALLY:|R'  @+ TALLY-BI AND!BYTE                                  @+ TALLY-BY OR!   @ TALLY-BA OR!U ;                          ( Fix up the instruction from reverse using a pointer to DATA.) : FIXUP<'   @+ ISS @ ISL @ + OR!BYTE   TALLY:|R'  CHECK32 ;                                                                     ( *************** END PREFERRED ****************************  )                                                                 ( Bookkeeping for a commaer using a pointer to the  )           ( BIBYBA information. Not used by the disassembler.     )       : TALLY:,, CELL+   @+ CHECK30 TALLY-BY AND!   @ TALLY-BA OR!U ;                                                                                                                                                                                                                                                                 : COMMA @+ >R  TALLY:,,  CHECK32   R> EXECUTE ;                 ( Build with an disassembly ROUTINE, )                          ( with the LENGTH to comma, the BA   )                          ( BY information and the ADDRESS that is executing the commaer) IS-A  IS-COMMA                                                  : COMMAER CREATE--  , 0 , , , , , DOES> REMEMBER COMMA ;                                                                        ( ------------- ASSEMBLER, SUPER DEFINING WORDS --------------)                                                                 CREATE PRO-TALLY 3 CELLS ALLOT  ( Prototype for TALLY-BI BY BA) : T! PRO-TALLY !+ !+ !+ DROP ;                                  ( Fill in the tally prototype with BA BY,)                      ( reversed BI information )                                     : T!R   REVERSE-BYTES T! ;                                                                                                                                                                      ( Get the data from the tally prototype back BA BY BI )         : T@ PRO-TALLY 3 CELLS +  @- @- @- DROP ;                       ( Add INCREMENT to the OPCODE a NUMBER of times, and generate ) ( as much instructions, all with the same BI-BA-BY from )       ( ``PRO-TALLY''  For each assembler defining word there )       ( is a corresponding family word )                              ( Words named "--" are mere placeholders. )                     : `FAM DUP >R T@ R> EX OVER + ; : `2L POP ;2DROP PUSH LOOPS ;   : 1FAMILY, `2L `FAM 1PI ;       : 2FAMILY, `2L `FAM 2PI ;       \ : 3FAMILY, `2L `FAM 3PI ;       : 4FAMILY, `2L `FAM 4PI ;     : xFAMILY| `2L `FAM xFI ; : FAMILY|R `2L `FAM XREVERSE FIR ;    : xFAMILY|F `2L `FAM DFI ;                                                                                                                                                                                                                                                                                                      ( ############### PART II DISASSEMBLER ##################### )                                                                  ( Tryers try to construct an instruction from current      )    ( bookkeeping. They can backtrack to show all possibilities.)   ( Disassemblers try to reconstruct an instruction from current) ( bookkeeping. They are similar but disassemblers take one )    ( more aspect  into account, a piece of actual code. They do)   ( not backtrack but fail. )                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ( ------------- DATA STRUCTURES --------------------------)     ( A row of dea's representing a disassembly)                     12 SET _DISS : !DISS AT _DISS !SET ;                           : +DISS TO _DISS ;              ( DISS SET+!)                   : DISS? AT _DISS ITEMS ;        \ : DISS? DISS SET? ;           \ : .DISS-AUX DISS @+ SWAP DO                                   \    I @ DUP IS-COMMA OVER IS-DFI OR IF I DISS - . THEN ID.     \ 0 CELL+ +LOOP CR ;                                            : .DISS-AUX ;CR DISS? LOOPS  J @ITEM AT _DISS  DUP                  IS-COMMA OVER IS-DFI OR IF AT _DISS ITEMS J - . THEN ID. ;  ( DISS-VECTOR can be redefined to generate testsets)            VARIABLE DISS-VECTOR     '  .DISS-AUX DISS-VECTOR !             ( Discard last item of `DISS' : DISS- 0 CELL+ NEGATE DISS +! ;) : DISS- _DISS DROP ;                                                                                                                                                                            ( ------------- TRYERS ----------------------------)                                                                            ( These tryers are quite similar:                               ( if the DEA on the stack is of the right type and if the)      ( precondition  is fullfilled it does the reassuring actions)   ( toward the tally as with assembling and add the)              ( fixup/posti/commaer to the disassembly struct. )              ( as if this instruction were assembled. Leave the DEA. )                                                                       : TRY-PI  DUP IS-PI 0;  AT-REST? 0; DUP >BI TALLY:, DUP +DISS ;                                                                                                                                                                                                                                                                                                                                                                                                 : TRY-xFI   DUP IS-xFI 0;                                          DUP >BI @ TALLY-BI @ CONTAINED-IN 0;                                DUP >BI TALLY:|                                                 DUP +DISS                                                ;                                                                                                                               : TRY-DFI   DUP IS-DFI 0;                                          DUP >BI @ TALLY-BI @ CONTAINED-IN 0;                                DUP >BI TALLY:|                                                 DUP +DISS                                                ;                                                                                                                                                                                                                                                                                                                                                                                               : TRY-FIR   DUP IS-FIR 0;                                            DUP >BI @ CORRECT-R TALLY-BI @ CONTAINED-IN 0;                    DUP >BI TALLY:|R                                                DUP +DISS ;                                                                                                              : TRY-COMMA   DUP IS-COMMA 0;                                        DUP >BY @ TALLY-BY @ CONTAINED-IN 0;                              DUP >BI TALLY:,,                                                DUP +DISS ;                                                                                                              : `GET_DISS DISS? DXEP LOOPS _DISS ;                            : REBUILD    !TALLY    DISS? 0;  `GET_DISS                              LOOPS @ TRY-PI TRY-xFI TRY-DFI TRY-FIR TRY-COMMA DROP ;                                                                                                                                                                                                 ( Generate bookkeeping such as to correspond with `DISS'. )     \ : REBUILD    !TALLY    DISS? IF                               \       DISS @+ SWAP !DISS DO  ( Get bounds before clearing)    \           I @ TRY-PI TRY-xFI TRY-DFI TRY-FIR TRY-COMMA DROP   \       0 CELL+ +LOOP  THEN ;                                                                                                   \ : BACKTRACK  (   ." BACKTRACKING"   )                         \    DROP DISS @ @- DISS !       (   DROP DISS @ 0 CELL+ - @ )  \ (   "Failed at :" TYPE DUP ID. CR  )  \     >NEXT%            \ (   DISS- )   \     REBUILD   \ ;                             ( Discard the last item of the disassembly -- it is either)     (  used up or  incorrect --. Replace DEA with the proper )      ( DEA to inspect from here.   )                                                                                                                                                                                                                                 : BACKTRACK   ." BACKTRACKING" DROP _DISS >NEXT% REBUILD ;      ( If the disassembly contains something: `AT-REST?' means )     ( we have gone full cycle rest->postits->fixups->commaers )     ( Return: the disassembly CONTAINS a result.              )     : RESULT? AT-REST? DISS? AND   BAD? 0= AND ;                                                                                    ( If present, print a result and continue searching for a)      ( new last item )                                                                                                               : .RESULT    RESULT? 0;                                                 DISS-VECTOR @EXEC                                               DISS-                                                           REBUILD                                                 ;                                                                                                                                                                                               \     % RESULT +DISS Spurious? Remove after next total test.    ( Try to expand the current instruction in `DISS' by looking)   (  whether    DEA fits. Leave the NEXT dea.                   )                                                                 : SHOW-STEP                                                             TRY-PI TRY-DFI TRY-xFI TRY-FIR TRY-COMMA                        .RESULT                                                         >NEXT%                                                  (       DUP ID.                                               )         BAD? IF BACKTRACK THEN                                          BEGIN DUP VOCEND? DISS? AND WHILE BACKTRACK REPEAT      ;                                                                                                                               ( Show all the instructions present in the assemblr vocabulary)                                                                                                                                 : SHOW-ALL                                                          !DISS   !TALLY                                                  STARTVOC BEGIN                                                     SHOW-STEP                                                    DUP VOCEND? UNTIL DROP                                      ;                                                                                                                               ( Show all the opcodes present in the assembler vocabulary )    : SHOW-OPCODES                                                      !DISS   !TALLY                                                  STARTVOC BEGIN                                                     DUP IS-PI IF DUP %ID. THEN >NEXT%                            DUP VOCEND? UNTIL DROP                                      ;                                                                                                                                                                                               ( Show at least all instructions valid for the "OPCODE" given)  : SHOW:                                                             !DISS   !TALLY     \  % DUP BEGIN                               ' DUP BEGIN                                                         SHOW-STEP                                                    OVER DISS? OVER VOCEND? OR UNTIL DROP DROP                 ;                                                                                                                               ( ------------- DISASSEMBLERS -------------------------------)                                                                  ( Contains the position that is being disassembled           )  VARIABLE AS-POINTER       HERE AS-POINTER !                                                                                     ( Get the valid part of the INSTRUCTION under examination    )  : INSTRUCTION  ISS @   ISL @   MC@ ;                                                                                            \ This is kept up to date during disassembly.                   \ It is useful for intelligent disassemblers.                   VARIABLE LATEST-INSTRUCTION                                                                                                     ( These disassemblers are quite similar:                     )  ( if the DEA on the stack is of the right type and if the    )  ( precondition is fullfilled and if the dissassembly fits,   )  ( it does the reassuring actions toward the tally as with    )  ( assembling and add the fixup/posti/commaer to the          )  ( disassembly struct.  Leave the DEA. )                                                                                                                                                                                                                                                                                                                                                                                                                         : DIS-PI                                                            DUP IS-PI 0;                                                    AT-REST?  0;                                                    DUP >BI OVER >CNT @  MC@ INVERT                                 >R AS-POINTER @ OVER >CNT @  MC@ R>   AND                       OVER >DATA @ = 0;  DUP >BI TALLY:,  DUP +DISS                       DUP LATEST-INSTRUCTION !  AS-POINTER @ ISS !                    DUP >CNT @ AS-POINTER +!  ;                                                                                             : DIS-xFI   DUP IS-xFI 0;                                          DUP >BI @ TALLY-BI @ CONTAINED-IN 0;                              DUP >BI @ INSTRUCTION AND   OVER >DATA @ = 0;                     DUP >BA @  COMPATIBLE? 0;                                         DUP >BI TALLY:|  DUP +DISS ;                                                                                                                                                           : DIS-DFI   DUP IS-DFI 0;                                          DUP >BI @ TALLY-BI @ CONTAINED-IN 0;                              DUP >BA @  COMPATIBLE? 0;                                         DUP >BI TALLY:|                                                 DUP +DISS                                                ;                                                                                                                               : DIS-DFIR   DUP IS-DFIR 0;                                        DUP >BI @ CORRECT-R   TALLY-BI @ CONTAINED-IN 0;                  DUP >BA @  COMPATIBLE? 0;                                         DUP >BI TALLY:|R                                                DUP +DISS                                                ;                                                                                                                                                                                                                                                               : DIS-FIR   DUP IS-FIR 0;                                          DUP >BI @ CORRECT-R   TALLY-BI @ CONTAINED-IN 0;                  DUP >BI @ CORRECT-R   INSTRUCTION AND                                              OVER >DATA @ CORRECT-R = 0;                    DUP >BA @  COMPATIBLE? 0;                                         DUP >BI TALLY:|R                                                DUP +DISS                                              ;                                                                                                                               : DIS-COMMA   DUP IS-COMMA 0;                                      DUP >BY @ TALLY-BY @ CONTAINED-IN 0;                              DUP >BA @  COMPATIBLE? 0;                                         DUP >BI TALLY:,,                                                DUP +DISS                                                ;                                                                                                                               ( Print a disassembly for the data-fixup DEA.             )     : .DFI                                                              INSTRUCTION   OVER >BI @ AND   OVER >DATA @ >> U.               %ID.                         ( DEA -- )                     ;                                                                                                                               ( Print a disassembly for the data-fixup from reverse DEA.)     : .DFIR                                                             INSTRUCTION   OVER >BI @ CORRECT-R AND   OVER >DATA @            >>      REVERSE-BYTES CORRECT-R U.                             %ID.                         ( DEA -- )                     ;                                                                                                                                                                                                                                                                                                                               ( Print a standard disassembly for the commaer DEA.   )         : .COMMA-STANDARD                                                   AS-POINTER @ OVER >CNT @ MC@ U.                                 DUP >CNT @ AS-POINTER +!                                        %ID.                         ( DEA -- )                     ;                                                                                                                               ( Print a signed disassembly for the commaer DEA.     )         : .COMMA-SIGNED                                                     AS-POINTER @ OVER >CNT @ MC@ .                                  DUP >CNT @ AS-POINTER +!                                        %ID.                         ( DEA -- )                     ;                                                                                                                                                                                                                                                               ( Print the disassembly for the commaer DEA, advancing)         (  `AS-POINTER' past   the comma-content              )         : .COMMA   DUP >DIS @ .COMMA-STANDARD ?;  DUP >DIS @EXEC ;                                                                      ( Print the DEA but with suppression, i.e.                       ignore those starting in '~' )                                 : %~ID. DUP IGNORE? IF DROP ELSE %ID. THEN  ;                                                                                   ( Print the disassembly `DISS'            )                     \ : .DISS   DISS @+ SWAP DO    I @                              CREATE `DISS 3 C, WAS IS-COMMA ,  WAS IS-DFI ,  WAS IS-DFIR ,   0 WARY `TDISS >, %~ID. .COMMA .DFI .DFIR ,<                     : .DISS   DISS? 0;  DISS? LOOPS J @ITEM AT _DISS                    DUP  `DISS  WTBL? `TDISS @EXEC ;                                                                                                                                                            VARIABLE I-ALIGNMENT  1 I-ALIGNMENT ! ( Instruction alignment ) ( From AS-POINTER show memory because the code there can't be ) ( disassembled. Leave incremented AS-POINTER.                 ) : SHOW-MEMORY  BEGIN CSTR  . ."  C, "                                        DUP I-ALIGNMENT @ MOD WHILE REPEAT ;                                                                               ( Dissassemble one instruction from AS-POINTER starting at DEA) ( Based on what is currently left in `TALLY!' )                 ( Leave a AS-POINTER pointing after that instruction. )                                                                                                                                                                                                                                                                                                                                                                                                                                                                         : ((DISASSEMBLE))    SWAP    DUP AS-POINTER !   >R                  3 SPACES    ( startdea -- ) BEGIN                                   DIS-PI DIS-xFI DIS-DFI DIS-DFIR DIS-FIR DIS-COMMA               >NEXT%                                                  (       DUP ID. ." : "  DISS-VECTOR @ EXECUTE                 )     DUP VOCEND? RESULT? OR UNTIL DROP                               RESULT? IF                                                        .DISS     \ Advances pointer past commaers                      LATEST-INSTRUCTION @ >PRF @ BA-XT !                             RDROP AS-POINTER @                                            ELSE                                                              R> SHOW-MEMORY                                                THEN                                                        ;                                                                                                                                                                                               ( Dissassemble one instruction from ADDRESS using the whole)    (  instruction set and starting with a clean slate. )           ( Leave an ADDRESS pointing after that instruction.           ) : (DISASSEMBLE)   !DISS !TALLY STARTVOC ((DISASSEMBLE)) ;                                                                       ( Forced dissassembly of one instruction from `AS-POINTER'. )   ( Force interpretation as DEA instruction. )                    ( This is useful for instructions that are known or hidden by ) (  an other instruction that is found first.                  ) : FORCED-DISASSEMBLY                                                !DISS   !TALLY   AS-POINTER @ SWAP ((DISASSEMBLE)) DROP ;                                                                   ( Dissassemble one instruction from address ONE to address TWO) : DISASSEMBLE-RANGE  SWAP   BEGIN DUP ADORN-ADDRESS                 (DISASSEMBLE) 2DUP 1+ U< UNTIL   2DROP  ;                                                                                   ( ********************* DEFINING WORDS FRAMEWORK *************) ( Close an assembly definition: restore and check.)             : END-CODE CHECK26 CHECK32 ; \ ; IMMEDIATE PREVIOUS             \   ?CSP ?EXEC CHECK26 CHECK32 PREVIOUS                         ( FIXME : we must get rid of this one ; IMMEDIATE )             \ : ;C POSTPONE END-CODE "WARNING: get rid of C;" TYPE CR ;     : ;C END-CODE ; \ "WARNING: get rid of C;" TYPE CR ;            \ The following two def`s must *NOT* be in the  wordlist.       \ PREVIOUS DEFINITIONS DECIMAL                                  \ ASSEMBLER                                                     ( Define "word" using assembly instructions up till END-CODE )  : CODE STK? ?? CODE: !TALLY ;  : ;CODE` STK? ??  LIT `;code , ;                                                                                                                                                                                                                                                                 ( One could put a ``SMUDGE'' in both. )                         \ : CODE ?EXEC (WORD) (CREATE) POSTPONE ASSEMBLER !TALLY !CSP   \ ; IMMEDIATE                                                   ( Like ``DOES>'' but assembly code follows, closed by END-CODE) \ : ;CODE                                                       \    ?CSP   POSTPONE (;CODE)   POSTPONE [   POSTPONE ASSEMBLER  \ ; IMMEDIATE                                                                                                                   ( ************************* CONVENIENCES *********************) ( Abbreviations for interactive use. In the current dictionary)     : DDD (DISASSEMBLE) ;                                           : D-R DISASSEMBLE-RANGE ;                                   ( ****************** NOTES ******************)                  ( 1. A DEA is an address that allows to get at header data  )   ( like flags  and names. In ciforth an xt will do. \ PREVIOUS )                                                                 \ ############## 8086 ASSEMBLER ADDITIONS ################### ) : ( ') WORD DROP ;  121 LOAD  \ CIASDIAS.NF  $Id: asi86.frt,v 2  0 0 4 FAMILY VALUE ASM-LINK ASMP DICTP TASMP ' ( DEFER (`      ( Albert van der Horst, HCC FIG Holland by GNU Public License)  M: R>` POP; M: >R` PUSH; : CELLS 2* ; : CELL+ 2+ ; : CELL- 2- ; : `CREATE DICT TO DICTP HERE TO ASMP 0 , TASMP , HERE ASM-LINK   , TO ASM-LINK CREATE  DICT ASMP ! EX  DICT 1+ @ #'-'- = 0;           ASMP  TO HERE  DICTP  TO DICT  ASM-LINK @  TO ASM-LINK ;  1 1 2 FAMILY CONST  &CELL CELL  : `+NOD CONST DOES> @ ASMP + ;  CELL -2 CELLS 6 FAMILY `+NOD L>N L>T `- L>C L>D L>O  : CFA ;    : `(D>L) DUP 2 CELLS - TO ASMP L>T @ TO TASMP ;                 : `DOES>C 3 - ;    : `IS-A `DOES>C CONST DOES> @ L>C @ = ;      : `+OFS CONST DOES> @ TASMP + ; : `D>L` HERE COMPILE `(D>L) ;;  : COMMAER `CREATE , , DOES> `D>L @EXEC ; `IS-A IS-COM           CELL  0 3 FAMILY `+OFS >BI >BY >BA              207 220 THRU                                                                    CELL BARY `BTABLE 1 , 1 ,  : 8<< bs : << LOOPS 2* ;             : ROTLEFT &CELL AND CELL+ `BTABLE @ UM* OR ;                    : XREVERSE XEP : REV-BYTES 0 `BTABLE ! 0                              CELL LOOPS 8<< &CELL J - `BTABLE C@ OR ;                  : T!R REV-BYTES    : T! HERE TO TASMP , , , ;                   : DFIX HERE CELL-  : XOR! DUP PUSH @ XOR POP ! ;                : W, ;DROP TWICE   : lsbyte, 0 $100 U/ SWAP    : IS, C, ;       \ system : 0s 2 ROTLEFT ;  ." WARNING: testing version on 8086" : 0s NOP ; \ By defining 0s as a NOP you get a normal 8086 ver  : `FML `IS-A ' CREATE , DOES> @ (JUMP AT FAMILY ;               : 1PI `CREATE , DOES> `D>L @ C, ;    `FML IS-1PI 1PI 1FAMILY,   : 2PI `CREATE , DOES> `D>L @ , ;     `FML IS-2PI 2PI 2FAMILY,   : xFI `CREATE , DOES> `D>L @ DFIX ;  `FML IS-xFI xFI xFAMILY|   : FIR `CREATE , DOES> `D>L @ DFIX ;  `FML IS-FIR FIR FAMILY|R   : DFI `CREATE , DOES> `D>L @ DFIX ;  `FML IS-DFI DFI xFAMILY|R                                                                  : `@H. @ H. ; : `BIBYBA  >BI `@H.  >BY `@H.  >BA `@H. ;         : `.NAME L>N @ ID. ;   : DROP DROP ;                                                                                            : L'   ' CELL- : L! TO ASMP                                     : L?   L>T @ TO TASMP `BIBYBA  SPACE  `.NAME SPACE                 L>D @ IS-COM IF ?ID. L>O @ THEN H. ;                         : N ASMP @  DROP #?;  L! ;                                                                                                      PRUNE                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ( ############## 8086 ASSEMBLER PROPER #######################) 0 CELL 0 T! $8000 ' ,  CFA  COMMAER (RX,) ( cell relative to)   0 1    0 T! $4000 ' C, CFA  COMMAER (RB,) ( byte relative IP)   0 2    0 T! $2000 ' W, CFA  COMMAER SG, (  Segment: WORD     )  0 1    0 T! $1000 ' C, CFA  COMMAER P,  ( port number ; byte )  0 1    0 T!  $800 ' C, CFA  COMMAER IS, ( immediate byte data)  0 CELL 2 T!  $400 ' ,  CFA  COMMAER IX,  ( immediate data-cell) 0 1    1 T!  $400 ' C, CFA  COMMAER IB,  ( immediate byte data) 0 CELL 8 T!  $200 ' ,  CFA  COMMAER X, ( i DATA address/offset) 0 1    4 T!  $200 ' C, CFA  COMMAER B, ( immed address/offset ) 0 2    0 T!  $100 ' W, CFA  COMMAER W, ( obligatory word     )  ( Bits in TALLY  1 OPERAND IS BYTE     2 OPERAND IS CELL  )     (                4 OFFSET   DB|        8 ADDRESS      DW| )     (               10 Register op        20 Memory op      )       (               40 D0                 80 [BP]           )                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ( By setting 20 an opcode can force)                            ( a memory reference, e.g. CALLFARO  )                          ( Only valid for 16 bits real mode  A0JUL04 AvdH )              $20 0 $700 0s T!                                                $0100 0s 0 8 xFAMILY|R X/S X/D P/S P/D /SI /DI -- /BX           \ [BX+SI] [BX+DI] [BP+SI] [BP+DI] [SI] [DI] [BP] [BX]           ( Fits in the hole, safe incompatibility)                       $A0 0 $0700 0s T! $0600 0s xFI  /BP                             $12 0 $0700 0s T!                                               $0100 0s 0 8 xFAMILY|R AX| CX| DX| BX| SP| BP| SI| DI|          $11 0 $0700 0s T!                                               $0100 0s 0 8 xFAMILY|R AL| CL| DL| BL| AH| CH| DH| BH|                                                                                                                                                                                                                                                                          $60 $000  $C000 0s T! $0000 0s xFI   D0|                        $24 $200  $C000 0s T! $4000 0s xFI   DB|                        $28 $200  $C000 0s T! $8000 0s xFI   DW|                        $10 $000  $C000 0s T! $C000 0s xFI   R|                         $08 $200  $C700 0s T! $0600 0s xFI   MEM| ( Overrules D0| [BP])                                                                 02 00 $3800 0s T!                                                $0800 0s 0 8 xFAMILY|R AX'| CX'| DX'| BX'| SP'| BP'| SI'| DI'| 01 00 $3800 0s T!                                                $0800 0s 0 8 xFAMILY|R AL'| CL'| DL'| BL'| AH'| CH'| DH'| BH'|                                                                 00 00 0002 0s T!  2 0s 0 0s 2 xFAMILY|R F| T|                   01 00 0001 0s T!  0 0s xFI  B|                                  02 00 0001 0s T!  1 0s xFI  W|                                                                                                                                                                  ( --------- two fixup operands ----------)                      00 00 $FF03 T!                                                   0008 $0000 8 2FAMILY, ADD, OR, ADC, SBB, AND, SUB, XOR, CMP,   00 00 $FF01 T!                                                   0002 $0084 2 2FAMILY, TEST, XCHG,                              $00 00 $FF03 T!   $0088 2PI MOV,                                $22 00 $FF00 T!   $008D 2PI LEA,                                                  $0001 $00C4 2 2FAMILY, LES, LDS,              00 $0400 $C701 T!  $00C6 2PI MOVI,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ( --------- one fixup operands ----------)                      $12 00 07 T!  08 $40 4 1FAMILY, INC|X, DEC|X, PUSH|X, POP|X,                     $90 1PI XCHG|X,                                $11 $0400 07 T!  $B0 1PI MOVI|B,                                $12 $0400 07 T!  $B8 1PI MOVI|X,                                00 $0400 $C701 T!                                                $0800 $0080 8 2FAMILY, ADDI, ORI,  ADCI, SBBI,                                         ANDI, SUBI, XORI, CMPI,                 02 $0800 $C700 T!                                                $0800 $0083 8 2FAMILY, ADDSI, -- ADCSI, SBBSI,                                                -- SUBSI, -- CMPSI,                                                                                                                                                                                                                                                                                                                                              00 00 $C701 T!                                                   $0800 $10F6 6 2FAMILY, NOT, NEG, MUL, IMUL, DIV, IDIV,          $0800 $00FE 2 2FAMILY, INC, DEC,                               0 $400 $C701 T! $00F6 2PI TESTI,                                02 00 $C700  T! $008F 2PI POP,      $30FE 2PI PUSH,                              $1000 $10FF 2 2FAMILY, CALLO,  JMPO,           $22 00 $C700 T!  $1000 $18FF 2 2FAMILY, FCALLO, FJMPO,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ( --------- no fixup operands ----------)                       01 00 $20100 0s T!  $0000 0s xFI  B'|                           02 00 $20100 0s T!  $0100 0s xFI  W'|                           8 $0200 $201 T!    02 $A0 2 1FAMILY, MOVTA, MOVFA,              0 $0400 $201 T!                                                  08 04 8 1FAMILY, ADDI|A, ORI|A, ADCI|A, SBBI|A,                                  ANDI|A, SUBI|A, XORI|A, CMPI|A,               00 00 $201 T!  $A8 1PI TESTI|A,                                              2 $A4 6 1FAMILY, MOVS, CMPS, -- STOS, LODS, SCAS,              02 $EC 2 1FAMILY, IN|D, OUT|D,                      00 $1000 $201 T!   02 $E4 2 1FAMILY, IN|P, OUT|P,                                                                                                                                                                                                                                                                                                                                               ( --------- special fixups ----------)                          00 00 $10100 0s T!                                              0100 0s 0 0s 2 xFAMILY|R Y| N|                                  00 00 $00E00 0s T!                                              $0200 0s 0 0s 8 xFAMILY|R O| C| Z| CZ| S| P| L| LE|             00 $4000 $10F T!  $70 1PI J,                                                                                                    00 00 $1800 0s T!                                               $0800 0s 0 0s 4 xFAMILY|R ES| CS| SS| DS|                       00 00 $18 T!   01 06 2 1FAMILY, PUSH|S, POP|S,                  02 00 $DF02 T! $08C 2PI MOV|S,                                  00   00 $10002 0s T!  00 0s xFI  1|                             00 $800 $10002 0s T!  02 0s xFI  V|     00 0 $1C703 T!           $0800 $00D0 8 2FAMILY, ROL, ROR, RCL, RCR, SHL, SHR, SAL, SAR,                                                                                                                                 ( --------- no fixups ---------------)                          $01 $0400 00 T!  $CD 1PI INT,                                   $0A $2200 00 T!  $9A 1PI FCALL,         $EA 1PI FJMP,           $02 $0100 00 T!   08 $C2 2 1FAMILY, RET+, FRET+,                $04 $8000 00 T!   01 $E8 2 1FAMILY, CALL, JMP,                  $00 $4000 00 T!  $EB 1PI JMPS,                                  $00 $0000 00 T!   08 $26 4 1FAMILY, ES:, CS:, SS:, DS:,          08 $27 4 1FAMILY, DAA, DAS, AAA, AAS,                           01 $98 8 1FAMILY, CBW, CWD, -- WAIT, PUSHF, POPF, SAHF, LAHF,   08 $C3 2 1FAMILY, RET,  FRET,                                   01 $CC 4 1FAMILY, INT3, -- INTO, IRET,                          01 $D4 4 1FAMILY, AAM, AAD, -- XLAT,                            01 $E0 4 1FAMILY, LOOPNZ, LOOPZ, LOOP, JCXZ,                    01 $F0 6 1FAMILY, LOCK, -- REPNZ, REPZ, HLT, CMC,               01 $F8 6 1FAMILY, CLC, STC, CLI, STI, CLD, STD,                \ CODE JAN MOV|SG, T| ES| R| AX| C;                             \ : BAD? T-BA @ : BADPAIRS? DUP 2/ AND $AAAA AND ;              \ : COMPATIBLE? T-BA @ OR BADPAIRS? 0= ;                        \ : CHECK26 AT-REST? 0= 26 ?ERROR ; : CHECK32 BAD? 32 ?ERROR ;  \ : CHECK31 2DUP SWAP CONTAINED-IN 0= 31 ?ERROR ;               \ : CHECK31A 2DUP OVER >R >> 1  OR OVER << R> <> 31 ?ERROR ;    \ : CHECK33 2DUP SWAP INVERT CONTAINED-IN 0= 31 ?ERROR ;        \ :CHECK28 2DUP AND 28 ?ERROR ;: CHECK29 2DUP OR -1 - 29 ?ERROR \ : CHECK30 DUP OLDCOMMA @ < 30 ?ERROR DUP OLDCOMMA ! ;         \ : OR! >R @I CHECK28 OR R> ! ; : OR!U >R @I OR R> ! ;          \ : AND! >R INVERT @I CHECK29 AND R> ! ;                        \ : TALLY:| @+ TALLY-BI AND!  @+ TALLY-BY OR! @ TALLY-BA OR!U ; \ : FIXUP>  @+ ISS @ OR!  TALLY:| CHECK32 ;                     \ : xFI   CHECK31 CREATE-- , , , , DOES> REMEMBER FIXUP> ;                                                                                                                                                                                                      \ : FIXUP-DATA @+ ROT SWAP << ISS @ OR! TALLY:| CHECK32 ;       \ : DFI   CHECK31A CREATE-- , , , , DOES> REMEMBER FIXUP-DATA ; \ : CORRECT-R 0 CELL+ ISL @ - ROTLEFT ;                         \ : TALLY:|R  @+ CORRECT-R T-BI AND! @+ T-BY OR! @ T-BA OR!U ;  \ : FIR CHECK31 CREATE-- REVERSE-BYTES , REVERSE-BYTES          \  , , ,    DOES> REMEMBER @+ FIXUP< TALLY:|R  CHECK32 ;        \ : DFIR  CHECK31 CREATE-- , REVERSE-BYTES , , , DOES> REMEMBER \ @+ SWAP >R << REVERSE-BYTES FIXUP< R>  TALLY:|R  CHECK32 ;    \ : (AND!BYTE) >R W>B INVERT C@I CHECK29 AND R> C! ;            \ : AND!BYTE BEGIN 2DUP (AND!BYTE) SWAP 8>>                     \               DUP WHILE SWAP 1+ REPEAT 2DROP ;                \ : (OR!BYTE) >R C@I CHECK28 OR R> C! ;                                                                                                                                                                                                                                                                                         ( The patch ofr the assembler doesn't belong in the        )    ( generic part. To be used when overruling, e.g. prefix)        ( Because there are no fixups-from-reverse that are larger thn) ( 2 bytes this trick allows to debug -- but not run -- 8086   ) ( assembler of 32 bits system. The pattern 00 01 {$100} to    ) ( fixup the last bit becomes 00 00 00 01 {$1000000} on a 16 bi) \ : OR!BYTE BEGIN 1- 2DUP (OR!BYTE) SWAP                        \           8>> DUP WHILE SWAP REPEAT 2DROP ;                   \ : TALLY:|R' @+ T-BI AND!BYTE @+ T-BY OR! @ T-BA OR!U ;        \ : FIXUP<' @+ ISS @ ISL @ + OR!BYTE TALLY:|R' CHECK32 ;        \ : TALLY:,, CELL+ @+ CHECK30 TALLY-BY AND! @ TALLY-BA OR!U ;   : ;@! XCHG PUSH J @ EX POP ! ;  : +! ;@! + ;  : XOR! ;@! XOR ;  \ : OR! ;@! CHECK28 OR ; : OR!U ;!@ OR ;                        \ : AND! ;@! INVERT J @ CHECK29 AND ;                                                                                                                                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   STATISTICS  OF GENERATED  CODE                                  LIKE bl .ALL  -  ALL CONSTATS  ( OF SOME TYPE)                  .CODE         -  ONLY CODE WORDS                                -FIND         -  DEA ( DICTIONARY ENTRY ADDRESS)                .NAMES        -  BY PART OF NAME                                .STAT         -  TIMES ( AND WAYS ?) OF USING A WORD            .UNUSED  .UNDEF .MONO .MANY  - SPECIAL ATTENTION                                                                                .             - TOKEN ( EXECUTABLE REPRESENTATION - ONE CELL)   .+            - NEXT CELL ADDRESS  ( .- PREV CELL)              .<            - ADDRESS TO TOKEN ( CAST FUNCTION )              .>            - TOKEN TO ADDRESS ( CAST FUNCTION )              <.>           - EQUALS TO @ ( FETCH    >.< - STORE)           vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv                                                                 :  .STAT        \ -  TIMES ( AND WAYS ?) OF USING A WORD                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        EXI?T >LOOP : (>NEXT NAME> 2+ ; : (TYP N>C @ ; : `H ." `$" H. ; : EXIT3 RDROP : EXIT2 RDROP : EXIT RDROP ; : C@I  J C@ ;        : WAS@ '  2+ @ ;  : CORA DUP C@ 1+ : -TEXT FOR PUSH CSTR        XCHG CSTR POP = IF CSWAP> NEXT -1 PUSH THEN  DROP DROP POP 1+ ; : ;FND DICT : ;FND2 BEGIN PUSH C@I  WHILE   DUP J EXECUTE POP     (>NEXT  REPEAT  0  EXIT2 ;  : DROP; DROP ; : .ALL ;2DROP ;FND  J (TYP : >PRINT = : >PRT? 0; : JID J ID. ; : C>N? ;FND J N>C - : `C <>0; DROP J J EXIT3 ; : `CN 2- : `M1  C>N? : `N  EXIT ?;    POP ID. ID. EXIT ; : `TO. `CN ,< ,T TO   : `AT. `CN ,< ,T AT   : B>N? ;FND J  N>C 2+ @ - <>0;  J (TYP #TARGET - `C ;           : ?ID. C>N? 0= ID. ?; `TO. `AT. 2+ 2+  B>N? `H ?; : ID-. CSTR    1- ;SPC TYPE ;                                                 : >LOOP 1- DUP 0< IF DROP EXIT ;THEN I 2- XCHG PUSH ;           0 VECTOR `v : `ADR@ ' TO `v POP ; : DO `ADR@ `v ;               \ 0 0 0 0  DO VALUE  4 TIMES T-HI T-LO LSAV  ADRSAV                                                                             0 VALUE `WW : `;WW `WW EX TO `WW : NOP ; 15 LOAD \ SRCH FW/BW   : `CR-H CR : .HL `WW H. ; : `LW `WW 2- @ ; 0 VALUE `N:          : `:ID? `WW C>N? TO `N: DROP `N: 0; `CR-H ." : " `N: ID. ;      : `@W+ `;WW @+ ; : `ASTR `;WW DUP ;NAME> [ID] ; 0 VECTOR `WA    : `WSCAN CSTR FOR STR 2+ @ `LW - EXIT ?; NEXT DUP XOR ;          0]> STR TO `WA RECURCE 0; `WA ;  : .. '. EMIT ;                            =, `?STR ,' `ASTR  3  C, >, (A"`  ("` (."` ,<       LIKE `?STR  =, `?INT ,' 1+    15  C, >, (CON` (>STK`             (DEF2` (VAR` (LIT` (DEF` (STK>` (SET` (CON2`                    (JMP` ;GO` (#IF` (NXT` (CALL` (OF` (SKP` ,<                    : SEE ' : @SEE TO `WW   : L bs >LOOP                            : WW `CR-H     `@W+ H.  : `W0 `LW ?ID. `?INT `?STR ;            : HACK ' : @HACK TO `WW : HL CR bs >LOOP `:ID? `@W+ DROP `W0 ;  : -HL `WW 23 - @HACK ;                                                                                                                                                                          : $+= TOKEN? CSTR 1+ SWAP '$ SWAP C!- C!- ; : A2I$ $+= NUM? ;    A2I$ BB EXIT                                                    BB 00 10 B4 4A CD 21 BC FE FB BE FE F7 E8 1E 00                 00 00 00 00 00 00 00 00 52 87 E6 5F 87 FB 59 5A                 56 FF D7 5E 52 51 53 50 1B C0 87 E6 5A 5F 5B EB                 63 59 49 51 78 0A 8B 1F EB 5A 0B C0 AD 72 F7 90                 43 43 EB 50 EB EB D1 24 D1 D0 3B C2 72 04 2B C2                 FF 04 EB DA 8B 0C D1 E9 73 02 03 C2 D1 D8 D1 1C                 EB CC 5F 97 EB 0B 91 AD 23 C1 F7 D0 EB 26 5F 87                 FA 57 EB 20 57 3C 50 AD EB 1A 5F AB EB F6 5F 8B                 0D AF EB 03 5F 59 51 57 EB 04 59 3D 8B C8 8D 74                 FE 89 04 91 8B 3F 43 43 D1 E7 72 03 FF E7 5F 53                 8B DF EB F0 91 AD 33 C1 EB EA 03 04 89 04 D1 D8                 EB E2 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                                                                                                                                \ ADDING TO COMPILER  [ ]       \ : DO POP XCHG EXECUTE ;       : `[ STATE TO CSTK> CASE`  >, ;  : COMP?  STATE #DOES = ;       : ]` CSTK> A" PAIRS!" ;` CSTK> TO STATE  COMP? 0; THEN` ;       : [` CALL`  `[ ; : [ HERE `[ ;  : []` [` ]` ;                   : ? IF   { TRUE}  POP RDROP XCHG                                    ELSE { FALSE} POP XCHG POP RDROP THEN                        [ ."  COMPILING MODE " CR ]  .( WAS) EXECUTE                                                                                    [ [ ." EQUALS " + . ]                                            [ 1 ." AND ONE " ] ." ADDITION OF " [ 2 ." TWO " ]             ]  EXECUTE                                                                                                                                                                                                                                                                                                                                                                                     \ <T  : .. STR H. ;   T>                                          TBL TIB + DUP TBL 2/ + DUP TBUF  STACK CSTK>   STACK <CSTK     LIKE KEY (,) (DEF3  WAS HERE 1- (,) (SET2                       : VQUAN (: (DEF3` (SET2` (VAR` ;                               LIKE bl 2- (,) (CON3  : QUAN (: (CON3` (SET2` (VAR` ;           LIKE bs (,) (EMT     : CONST.C (: (EMT` (CON` ;                 'DO (,) 14 TIMES  EXIT X  (IF (IF (JUMP (JMP ;GO ;GO  (#IF (#IF  (NEXT (NXT  PUSH PUSH  (CALL (CALL  (OF (OF  POP POP J J (" ("   (A" (A"  (." (."                                              : `;STK> CSTK> EX TO CSTK> ;    : `;<STK <CSTK EX TO <CSTK ;    : H.-@ HERE : .-@ 2- @ ;  : RANGE? T-LO T-HI WITHIN ;           : THEN` CSTK> DUP @ (IF TO RLS>` HERE 2/ $8000 XOR SWAP! ;      0 VECTOR vALIGN : `STR, ;HERE (S! DROP ; : STR, `STR, vALIGN ;  : STK? AT <CSTK ITEMS AT CSTK> ITEMS + ;                        : CSWAP>` `;STK> `;STK> SWAP ;  : <CSWAP` `;<STK `;<STK SWAP ;                                                                  : "` ("` : ," '" : ", WORD : CSTR, CSTR STR, ;                  : A"` (A"` ," ;  : ."`  (."` ," ;  : " HERE ," ; : ,T bl ", ;   : M: ';  : ?M: CREATE ", DOES> SEVAL ; { MACROSES }             : AHEAD` (JMP` : MARK>` MRK>` TO CSTK> ;                        : IF` (IF` MARK>` ; : CALL`  (CALL` MARK>` ; ' IF`   =: WHILE`  : FOR` PUSH` AHEAD` : BEGIN` HERE TO <CSTK ; : `THEN EX THEN` ; : NEXT` THEN`   : <NEXT`  (NXT` : <RES` <CSTK <RLS` ;           : FOR>` PUSH` BEGIN` ;  : DROP, LIT DROP , ;                    : ELSE` AHEAD` CSWAP>` THEN` ;  : FOR?`  (NXT` MARK>` ;         ' ELSE` =: ENDOF`     : OF`  (OF` MARK>` ; : CASE` 0 TO CSTK> ; : REPEAT` `THEN : AGAIN` (JMP` <RES` ; : UNTIL` (IF` <RES` ;    : ;CASE` DROP, BEGIN CSTK> DUP                                                 WHILE  TO CSTK> THEN` REPEAT DROP ;                                                                                                                                                                                                              \ EXIT \ TO 146 BLOCK MOVED ORIGINAL 15                         : #IF` (#IF` MARK>` ;                                                                                                           : .( ') WORD ". ;       : ID-. CSTR    1- ;SPC TYPE ;           : (A,) ,  H.-@ : e?RANGE RANGE? 0= A" RANGE!" ;                 ' (A,) 3 OPER[] !  1 TO T-LO                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    \ TAIL RECURSION OPTIMIZER                                                                                                      : `:=? @ LIT ,< LIKE Z, , >, = ;  ' `:=? TO vIS:?               : ;;` X`  STK? <>0; : ,<` ,<` ;                                 : `x??x EX #?? : `(@H, @H- vTOC>. TO <CSTK ;                    : `?? `x??x : `H@:? HERE @- DROP vIS:? ;        : ;THEN` `THEN  : ;` `H@:? ;;` 0; H- `(@H, AGAIN` ;          : ?;` `?? UNTIL` ; : #?;` `?? (#IF` <RES` ;        : :;` `??  ;GO` <RES` ;                                                                         \ 17 LOAD        143 145 THRU  \ 137 LOAD                       \ 137 LOAD   114 121  THRU      \ 17 LOAD  \ 144 LOAD           \ 206 LOAD    \ ASSEMBLER      : .. '. EMIT ;                                                                                                                                                                                                                                                                                   \ : NIP SWAP : DROP DROP : NOP ; \ DICTIONARY SEARCH            : EXIT3 RDROP : EXIT2 RDROP : EXIT RDROP ; : C@I  J C@ ;                          : (>NEXT NAME> 2+ ;     : (TYP N>C @ ;        : WAS@ '  2+ @ ;          : `H ." `$" H. ;                      : CORA DUP C@ 1+ : -TEXT                                              FOR PUSH CSTR XCHG CSTR POP = IF CSWAP> NEXT                    -1 PUSH THEN  DROP DROP POP 1+ ;                          : ;FND DICT : ;FND2 BEGIN PUSH C@I                                       WHILE   DUP J EXECUTE POP  (>NEXT  REPEAT  0  EXIT2 ;  : C>N? ;FND J N>C - : `C <>0; DROP J J EXIT3 ;                  : `CN 2- C>N?  : `N  EXIT ?; POP ID.   ID. EXIT ;               : `TO. `CN ,< ,T TO   : `AT. `CN ,< ,T AT                       : .ALL ;2DROP ;FND J (TYP : >PRINT = : >PRT? 0; : JID J ID. ;   : -FIND TOKEN? : FND  ;FND J CORA `C ;                           T> \   SEARCHBUF C@ TO BUF-LEN  BLOCK-SEARCH ;                                                                                 EXI?T DUPU+    : .B  BLK. 1K LTIB - 1L U/ . KEY : DROP; DROP ;                                                                  : THRU  ;RANGE LOOPS DXEP+ : LOAD DUP '# EMIT .  LOAD ;                                                         \ .B LOAD ;     : +THRU ;RANGE LOOPS DXEP+ : +LOAD BLK + LOAD ;                                                                                 : `~POSIBLE? J C@ - DUP 0< 0; RDROP    : `SRCH; 2DROP 0 EXIT ;                    : IN-STR> SUCSTR : SRCH> PUSH `~POSIBLE? FOR>  DUP J CSTR  -TEXT EXIT2 ?; 1+ <NEXT DUP `SRCH; ;               : DUPU+ DXEP + ; : <IN-STR SUCSTR : <SRCH PUSH `~POSIBLE? DUPU+      FOR>  DUP J CSTR  -TEXT EXIT2 ?; 1- <NEXT DUP `SRCH; ;                                                                                                                                                                                                                                                                                                                                     : B>N? ;FND J  N>C 2+ @ - <>0;   J (TYP #TARGET - `C ;          : `SHN6  PUSH PUSH PUSH  CALL  POP POP POP                      : `SHN3  THEN  SPACE 3 LOOPS ROT DUP H. ;                       : T?ID. DUP 0< OVER 2* RANGE? AND IF 2*  THEN                   : ?ID.   C>N? 0= ID. ?; `TO. `AT. 2+ 2+                                 B>N? `H ?; CSTR 1- ;SPC    TYPE ;                       : SHN CR POP J H. PUSH J H. I H. `SHN6 I @                           ?ID. KEY      DROP  : NOP ;                                : .CODE ;2DROP ;FND DROP J N>C @+ >PRINT ;                      : .WORDS ;2DROP ;FND DUP >PRINT ;                               : .NAMES ;2DROP ;FND J IN-STR>  >PRT? ;                         : HIDE -FIND #?? 1+ '` : CSWAP! SWAP C! ;                       : HIDE-TEST -FIND IF ID. ; THEN DROP ;                                                                                                                                                                                                                          : SIT ;   250 CONST `BLOCKS  CREATE `SEARCHBUF 80 ALLOT         : `BLK>LINES `BLOCKS 1H U* ; : S0! 0 TO SCR  0 TO XY ; \        : AT-VLINE 1H U/MOD TO SCR 1L U* ;                              : AT-VMEM AT-VLINE 1L 1- OR  DUP TO XY  : AT-SCR SCR BLOCK + ;  : SRCH XY AT-SCR 1K XY - `SEARCHBUF SRCH> DUP  TO XY 0;           XY 0 AT-SCR - `SEARCHBUF C@ + >XY E ; >, BEGIN SCR 1+ TO SCR  : `BLOCKSRCH  SCR `BLOCKS U< 0;  SRCH XY UNTIL ;                : S bl : `BLOCKSEARCH  WORD C@ IF  TBUF `SEARCHBUF PLACE  THEN    `SEARCHBUF C@ 0; `BLOCKSRCH ;                                 : S" '"  `BLOCKSEARCH ; : ?S TOKEN? 1+ C@ `BLOCKSEARCH ;        : S?EL `BLK>LINES LOOPS J AT-VMEM  C@ bl - 0; E ;               : cr>EL FLUSH :; S?EL `BLK>LINES LOOPS cr J AT-VMEM C! UPDATE ; : bl>EL FLUSH :; `BLK>LINES LOOPS bl J AT-VMEM C! UPDATE ;      CR \ .( ABRAKADABRA)                                                                                                                                                                            \ DEBUGGER  : ;[] '[ EMIT EX '] EMIT ; : ;CR EX CR ;             HERE DOES, >, PUSH XCHG CSTR POP SCAN 1+ 0;  ;SPC ;[]           DUP ". CSTR + ;     =, `?STR 3 C, >, (A"  (" (." ,<            0 VALUE `WW : `;WW `WW EX TO `WW ;  : `STR EX DUP 2- @ `?STR ;  : `:ID. DUP C>N? NOP #?; XEP OVER CALL ." : " ID. ;THEN : ``CR-  CR H. ; : `CR-H `:ID. ``CR-  ?; ;  : `CR- `:ID. DROP; ?; ;     ' ?ID. 2+ VALUE vDBG  : SEE ' : @SEE TO `WW : L `;WW bs LOOPS   : WW `CR-H @+ OVER H.  : `W0 `STR XEP vDBG PUSH ;               : `;TYPE  DUP 1H - 1H SPACE ;[] TYPE ;                          : WDUMP bs ?DU ;DROP LOOPS CR DUP H. SPACE bs LOOPS STR H. ;    : DUMP 1H ?DU ;DROP : DU LOOPS CR DUP H. SPACE `;TYPE :;          1H LOOPS CSTR B. ; \ SPC W>B 1H U/MOD  TWICE  DIG. ;          : HACK ' : @HACK TO `WW : HL CR bs LOOPS `;WW `CR- @+ `W0 ;     : -HL `WW 23 - @HACK ;  : .HL `WW H. ;                                                                                                                                                          : IF` COMPILE (IF MRK>` ;       : AHEAD` COMPILE (JUMP  MRK>` ; : WHILE` IF`    : CSWAP` SWAP ; : `THEN EX  : THEN` RES>` ;     : CALL`  COMPILE (CALL MRK>` ;  : FOR?`  COMPILE (NEXT MRK>` ;  : FOR`  COMPILE PUSH  AHEAD` : BEGIN` <MRK` ;                   : FOR>`  COMPILE PUSH  BEGIN` ;                                 : NEXT` CSWAP`  THEN`   : <NEXT` COMPILE (NEXT  <RES` ;         : ENDOF` : ELSE` AHEAD` CSWAP` THEN` ;                          : #IF` COMPILE (#IF MRK>` ; : OF`  COMPILE (OF MRK>` ;          : REPEAT` `THEN CSWAP` : AGAIN` COMPILE (JUMP <RES` ;           : UNTIL` COMPILE (IF <RES` ;    : ;THEN` `THEN COMPILE EXIT ;   : "` COMPILE (" : (",) '"                                       : (?",)  WORD : CSTR, CSTR : STR, ;HERE (S! DROP ;              : A"` COMPILE (A" (",) ;        : ."` COMPILE (." (",) ;                                                                                                                                                                                                        : B>N? ;FND J  N>C BDY@ - <>0;           \ CALL                   J (TYP (LIT ,< LIKE (VAR` , >, - `C ;  \ CALL   -  `C ;       : T?ID. DUP 0< OVER 2* RANGE? AND IF 2*  THEN                   : ?ID.   C>N? 0= ID. ?; `TO. `AT. 2+ 2+                                 B>N? `H ?; CSTR 1- ;SPC    TYPE ;                       : C>N? ;FND J N>C - : `C <>0; DROP J J 3RDR; ;                  : `CN 2- C>N?  : `N  RDR; ?; POP ID.   ID. RDR; ;               : `TO. `CN ,< ,T TO   : `AT. `CN ,< ,T AT                                                                                        HERE DOES, >, PUSH XCHG CSTR POP SCAN 1+ 0;  ;SPC ;[]           DUP ". CSTR + ;     =, `?STR 3 C, >, (A"` ("` (."` ,<                                              : `STR EX DUP 2- @ `?STR ;  : `:ID. DUP C>N? NOP #?; XEP OVER CALL ." : " ID. ;THEN : ``CR-  CR H. ; : `CR-H `:ID. ``CR-  ?; ;  : `CR- `:ID. DROP; ?; ;     ' ?ID. 2+ VALUE vDBG                                                                                                            \  CONSTANTS , VARIABLES ...                                                                                                    ZDO VALUE 13  TIMES  HERE  DICT   CNTC   LTIB  ETIB  BLK                        STATE  dea  ltib  EOS  SCRH  SCR  BASE          ZDO DEFER  7  TIMES                                                   ERR  OK.  ACCEPT  SOURCE   HEADER  FIND  TOKEN?           ZDO VECTOR 1  TIMES   vWAIT                                     ZDO VQUAN  2  TIMES  vKEY  vEMIT                                ZDO QUAN   1  TIMES  LastChar                                   #DO CONST.C 4 TIMES  32 spc  8 bs  10 lf  13 cr                 #DO CONST 15  TIMES                                                 26 eof  2 CELL  64 1L  1024 1K  16 1H  1 1  48 '0'  128 TBL   -512 TIB  -256 TBUF  $8000 &SIGN  124 NPAD  255 &BYTE  256 1B    3 TRI                                                                                                                                                                                        \ PRIMITIVES FOR VALUE VAR CONST QUAN VECTOR VQUAN  AND VALUES  : SIGN? &SIGN : AND  NAND NOT ;  : = XOR : 0= IF ,<  0 CONST 0  : - CALL { NEG} : + +2/ DROP ;   : ;DROP EX DROP ;              : < - : 0< SIGN?    0 ?; THEN ,<    -1 CONST -1                 : (CON3 RSKIP : (CON2 RSKIP : (CON  @R+   : EXIT RDROP : NOOP ; : 0>=; SIGN?  : 0; EXIT ?; ;  : 0<; SIGN? : 0<>; NOOP ?; EXIT ; : (DEF3 RSKIP : (DEF2 RSKIP : (DEF  @R+ RDROP : EXECUTE  PUSH ; : (+ @R+ +2/ : .EXIT POP : 2DROP XOR DROP ;   : @I J : @ PUSH    (CON ;  : ABS 0>=; : NEG  THEN { - !!!} NOT : 1+ (+ ,< 1 ,     : DX+ 1+ : DXEP DUP : XEP XR EXECUTE : (VAR  POP ; : (LIT @R+ ; : 0-ROT 0 : -ROT CALL : USWAP XEP THEN : SWAP PUSH : XPOP XR     POP ;  : (B& DXEP : W>B &BYTE AND ;        : ;SWAP EX SWAP ;   : TUCK SWAP : OVER PUSH DUP XPOP ;  : OVER- OVER - ;            : (SET2 RSKIP : (SET !R+ EXIT ; : I J ; : !I J : ! PUSH (SET ;                                                                                                                                  : ZSKIP DUP 0<>;  DUP : ..RSKIP XOR : .RSKIP DROP : R2+ RSKIP ; : (#IF DUP  (DEF ?; RSKIP ;  : (OF OVER-  ..RSKIP ?;  (DEF ;    : ;XOR EX XOR ; : [TIMES]  POP XR  : TIMES SWAP  : >TIMES PUSH  : LOOPS FOR J EXECUTE NEXT         : EXIT2 POP POP XOR DROP ;   : 256* TWICE : 16* TWICE : 4* TWICE : 2* DUP + ; : 2- (+ ,<      -2 ,    : !- 2- DXEP ! ; : @- 2- DXEP @ ;  : ROT USWAP SWAP ;  : W>BB (B&  : 256/ TWICE : 16/ TWICE : 4/ TWICE  2/ ;           : (& @R+ AND EXIT ; : (H& DXEP : 1H& (& ,< 15 ,  : 2+ (+ ,< 2 , : 1H/% (H& 16/ ;  : 1B/% (B& 256/ ;                             : 1- (+ ,< -1 ,  : C!+ PUSH W>B @I $FF00 AND XOR !R+ R1- POP ;  : C!- 1- DXEP : C! C!+ DROP ; : C@+ PUSH @R+ W>B R1- POP ;      : PERFORM @ EXECUTE ; : OR NOT PUSH NOT POP NAND ;              : ;NIP  EX : NIP PUSH DROP POP ;  : (DOS IO ,< $21CD , $C3 C,   : (VID IO ,< $10CD , $C3 C,     : (KBD IO ,< $16CD , $C3 C,                                                                                                                                     : C@I J : C@ ;NIP : CSTR PUSH @R+ R1- XR POP  W>B ;             : SWAP! PUSH : (!X  XR (SET ;  : (INI POP (!X ; \ SAVE STATE    : ;SIGN? 0; EX : SGN^ &SIGN XOR ;   : A! PUSH XA EXIT ;         : (LARY 2* : (WARY 2* : (BARY POP + ;   : 0SWAP 0 SWAP ;        : WITHIN OVER - PUSH - POP : U< SWAP NEG ;NIP +2/ 0< ;          : !+ PUSH !R+ POP ;  : @+ PUSH @R+ POP ; : STR PUSH @R+ XPOP ;  : ;@! XR PUSH J @ EX POP ! ; : INC ;@! 1+ ; : DEC ;@! 1- ;      : (@R @R+ J + @ ; : (!R @R+ J + ! ;         : 2DUP OVER OVER ;  : 0;A 0 : ;A XR XA EXECUTE XA EXIT ;                            : D2* 0;A -/ ; : D2/ 0;A +* ; : ;MAX 2DUP EX IF XEP THEN DROP ; : UMIN ;MAX U< 0= ; : ZLPH 0 : LPH 1H LOOPS ; : UMAX ;MAX U< ;  : U* ;DROP : UM* ;A ZLPH +* ;                                   : U/ ;NIP SKIP : UMOD ;DROP : U/MOD ;SWAP ;A ZLPH -/ ;          : H/MOD 0 1H  : UM/MOD ;SWAP ;A LPH -/ ;                                                                                                                                                        : ICORA J : CORA DUP C@ 1+ : -TEXT FOR PUSH CSTR XR CSTR POP =         IF CSWAP> NEXT  THEN  2DROP POP 1+ ;                     : CMOVE 2DROP :; : CMV LOOPS PUSH CSTR POP  C!+ ;               : ;HERE HERE EX TO HERE ;                                       : ALIGNED ;HERE : ALIGN 1+ : >EVEN (& ,< -2 ,                   : ;SPC EX : SPACE TO spc ;                                      : KEY vWAIT vKEY ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              : DIG? [ - DUP BASE U< ] '0' - : 9>? 9 OVER U< 7 AND ;          : ALPHA 9>? + '0' + ; : UCSTR SWAP XEP CSTR ;                   : (ASTR J POP POP CSTR + ALIGN PUSH PUSH ;  : (TYPE (ASTR : ".  CSTR : TYPE ;DROP LOOPS CSTR : ?EMIT DUP spc U< IF DROP '. THEN : EMIT CNTC 1+ TO CNTC vEMIT ;          : ID. ;SPC ". ;         : H. 1B/% CALL : B. ;SPC THEN 1H/% TWICE : DIG. ALPHA EMIT ;    : . DUP 0< IF '- EMIT NEG THEN                                  : U. lf TO BASE ;SPC : NUM. BASE U/MOD ZSKIP RECURSE DIG. ;     : WTBL? UCSTR : SCAN PUSH XR PUSH J FOR STR J - IF CSWAP> NEXT  : `SC RDROP J PUSH : `SC2 THEN POP XR 2DROP POP XR POP NOT + ;  : BTBL? UCSTR : BSCAN W>B PUSH XR PUSH J FOR CSTR J  XOR            `SC2 ?; NEXT  `SC ;        : (>NEXT CSTR + $2 + ;                                                                                                                                                                                                                                                                           : PARSE W>B  PUSH  SOURCE LTIB DUP  PUSH - DUP POP I spc =       IF NIP    FOR CSTR J = IF CSWAP> NEXT   : `PARSE; POP 1+ DUP   : `PARSE2 TO LTIB EXIT ;THEN 1- DUP POP 1+ THEN  FOR CSTR J -    IF CSWAP> NEXT  DROP `PARSE; ; THEN 1-  OVER - POP RECURSE ;   : TOKEN  spc     : WORD PARSE TBUF     \ ` CHAR IS AUTO TO END  : S! XEP &BYTE UMIN J C!+ J C@ CMV NIP '` SWAP! ;                                                                               : N>C 2- @ ;  : <#>. DROP ;                                     : (AC   { ADR CNT / ADR CNT1 } OVER + PUSH DUP                    BEGIN  KEY     CASE                                                cr OF  DUP XR   DROP  ENDOF                                     bs OF  2DUP XOR IF 1- TO bs SPACE  TO bs THEN  ENDOF            DUP spc 1B WITHIN  IF DUP EMIT SWAP C!+ DUP THEN                         ;CASE    DUP I =                                    UNTIL RDROP OVER - 1 : SPACES LOOPS SPACE ;                                                                                   : ;DEA DICT : ;DEA2 2+ BEGIN PUSH C@I   \ DEA: F:ADR F:NAME       WHILE  DUP J EXECUTE POP : FND1-  (>NEXT  REPEAT  0  EXIT2 ;  : C>N? ;DEA J N>C - : `C 0<>; DROP J J : EXIT3 RDROP EXIT2 ;    : -FIND TOKEN? : FND  ;DEA J CORA `C ; : FNDC DICT 2+ FND1- ;   : OVR_C@ OVER C@ ; : (BASE! @R+ TO BASE EXIT ; : `TNUM OVR_C@   : `BAS*+ -ROT PUSH  PUSH PUSH BASE U* POP + POP POP             : STR1+ 1- XEP 1+ ; : `NBAS  ROT 1- W>B 1+ TO BASE 0-ROT ;      : DECI (BASE! ,< 10 , : `-? OVR_C@ '- = 0;  STR1+ EX XEP NEG ;  : HEX (BASE! ,< 16 , : BINARY (BASE! ,< 2 ,                     CREATE `NTBL 4 C, '' C, '# C,  '$ C, '% C,                      : `STBL (WARY ,< 'T `TNUM  , 'T `NBAS  , 'T HEX  , 'T BINARY  , : CNUMBER? CSTR  : NUMBER? 0-ROT <#>. #?; `-? DECI    BEGIN          <#>. #?; OVR_C@ `NTBL BTBL? DUP 0< IF DROP                      OVR_C@ DIG?  <#>. ?; `BAS*+ ELSE PUSH STR1+  .EXIT #?;         POP `STBL PERFORM THEN  DUP 0= UNTIL NIP ;                                                                                  : ;, EX : , ;HERE !+ ; : (OP, @R+ RDROP , ;  : DEA>ADR 2- @ ;   : (LIT, (OP, (LIT ,<   : (;, (OP, ;;  : ;DICT DICT EX TO DICT ; : ADR>TOK  1+ 2/ &SIGN XOR ; : ALLOT ;HERE + ; : TOK>ADR 2* ;   : (EXEC DEA>ADR EXECUTE ;  : (, DEA>ADR ADR>TOK , ;             : NUM?, ;, (LIT, : NUM? CNUMBER?  : ?? A" ?" ;                  : (TOKEN? TOKEN DUP C@ : #?? 0= ?? ; : >DICT ;DICT S! ;         : MODE[] (WARY ,<  'T NUM?  , 'T (EXEC  , 'T NUM?,  , 'T (,  ,  : STATE! POP TO STATE ;      : DO-STATE TBUF STATE EXECUTE ;    : >,  { COMPILER } STATE! PUSH I INC I FNDC I DEC IF 1 EXIT ;         THEN POP FNDC IF TRI ;THEN CELL ;                         : ,<`  { INTERPRET}  STATE! FND : TRUE?  0 ?; 1 ;               : OPERATION? DO-STATE MODE[] ; : EVAL DUP TO LTIB + TO ETIB     : FROM-STREAM-GET TOKEN C@ 0; OPERATION? PERFORM RECURSE ;      : (: >, : (`:  : =H HERE : =: TOKEN? >DICT ADR>TOK ;DICT !- ;                                                                                                                                   : FGET `FBUF [ DROP  cr : EOS! EOS 1+ TO EOS ]                    AT `FBUF 1 FHTOP FREAD  _AX 0;  { IF EOF THEN EOS}              DROP `FBUF  DUP eof XOR 0; RDROP  ; { CONTROLS - LIKE BL }    : ;FILE TO HANDLES  AT KEY @ XCHG PUSH LIT FGET TO KEY               EX POP TO KEY      : `CLOSE1 HANDLES FCLOSE ;              : ;TI BLK XCHG LTIB PUSH ETIB PUSH PUSH                           CALL EX POP POP POP THEN  TO BLK TO LTIB TO ETIB              : /BLK  BLK 0; 0 TO ETIB ; : `// EOS 0; : // 0 TO LTIB ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        